"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rest = exports.RestError = void 0;
const undici_1 = require("undici");
const url_1 = require("url");
class RestError extends Error {
    json;
    constructor(json) {
        super(json.message);
        this.json = json;
    }
}
exports.RestError = RestError;
/**
 * A Rest helper for Lavalink
 */
class Rest {
    /**
     * Private base request function
     * @param node The lavalink node
     * @param path Route starting with /
     * @param init Request init if any
     * @param requires Properties of the lavalink node the route requires
     * @throws {RestError} If lavalink encounters an error
     */
    static async baseRequest(node, path, init, requires) {
        if (requires && !requires.every(r => !!node[r]))
            throw new RestError({ timestamp: Date.now(), status: 400, error: "Bad Request", message: `Node ${requires.join(", ")} is required for this route. Did you forget to connect?`, path });
        if (!init)
            init = {};
        if (!init.headers)
            init.headers = {};
        Object.assign(init.headers, { Authorization: node.password });
        const res = await (0, undici_1.fetch)(`http://${node.host}:${node.port}${path}`, init);
        let body;
        if (res.status !== 204 && res.headers.get("content-type") === "application/json")
            body = await res.json();
        else if (res.status !== 204)
            body = await res.text();
        else
            body = undefined;
        if (body && body.error)
            throw new RestError(body);
        return body;
    }
    /**
     * A helper for /v?/loadtracks endpoint
     * @param node The LavalinkNode
     * @param identifer The thing you want to load
     * @throws {RestError} If lavalink encounters an error
     */
    static load(node, identifer) {
        const params = new url_1.URLSearchParams();
        params.append("identifier", identifer);
        return Rest.baseRequest(node, `/v${node.version}/loadtracks?${params}`, undefined, ["version"]);
    }
    static decode(node, tracks) {
        if (Array.isArray(tracks)) {
            return Rest.baseRequest(node, `/v${node.version}/decodetracks`, {
                method: "POST",
                body: JSON.stringify(tracks),
                headers: { "Content-Type": "application/json" }
            }, ["version"]);
        }
        else {
            const params = new url_1.URLSearchParams();
            params.append("track", tracks);
            return Rest.baseRequest(node, `/v${node.version}/decodetrack?${params}`, undefined, ["version"]);
        }
    }
    /**
     * A helper for /version
     * @param node The lavalink node
     * @throws {RestError} If lavalink encounters an error
     */
    static version(node) {
        return Rest.baseRequest(node, `/version`);
    }
    /**
     * A helper for PATCH /v?/sessions/:sessionId
     * @param node The lavalink node
     * @throws {RestError} If lavalink encounters an error
     */
    static updateSession(node) {
        return Rest.baseRequest(node, `/v${node.version}/sessions/${node.sessionId}`, {
            method: "PATCH",
            body: JSON.stringify({ resuming: node.resuming, timeout: node.resumeTimeout }),
            headers: { "Content-Type": "application/json" }
        }, ["version", "sessionId"]);
    }
    /**
     * A helper for PATCH /v?/sessions/:sessionId/players/:guildId
     * @param node The lavalink node
     * @param guildId The Id of the guild
     * @param data The update data
     * @param noReplace If the event should be dropped if there's a currently playing track
     * @throws {RestError} If lavalink encounters an error
     */
    static updatePlayer(node, guildId, data, noReplace = false) {
        return Rest.baseRequest(node, `/v${node.version}/sessions/${node.sessionId}/players/${guildId}${noReplace ? `?noReplace=${noReplace}` : ""}`, {
            method: "PATCH",
            body: JSON.stringify(data),
            headers: { "Content-Type": "application/json" }
        }, ["version", "sessionId"]);
    }
    /**
     * A helper for DELETE /v?/sessions/:sessionId/players/:guildId
     * @param node The lavalink node
     * @param guildId The Id of the guild
     * @throws {RestError} If lavalink encounters an error
     */
    static destroyPlayer(node, guildId) {
        return Rest.baseRequest(node, `/v${node.version}/sessions/${node.sessionId}/players/${guildId}`, { method: "DELETE" }, ["version", "sessionId"]);
    }
}
exports.Rest = Rest;
//# sourceMappingURL=Rest.js.map