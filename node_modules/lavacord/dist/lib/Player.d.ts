/// <reference types="node" />
import { EventEmitter } from "events";
import type { LavalinkNode } from "./LavalinkNode";
import type { Manager } from "./Manager";
import type { PlayerUpdateVoiceState, JoinOptions } from "./Types";
import type { EventOP, PlayerState, Equalizer, Filters, PlayerUpdate, UpdatePlayerData, UpdatePlayerResult, DestroyPlayerResult, Player as APIPlayer } from "lavalink-types/v4";
/**
 * The Player class, this handles everything to do with the guild sides of things, like playing, stoping, pausing, resuming etc
 */
export declare class Player extends EventEmitter {
    node: LavalinkNode;
    id: string;
    /**
     * The PlayerState of this Player
     */
    state: Partial<PlayerState> & {
        filters: Filters;
    };
    /**
     * Whether or not the player is actually playing anything
     */
    playing: boolean;
    /**
     * When the track started playing
     */
    timestamp: number | null;
    /**
     * Whether or not the song that is playing is paused or not
     */
    paused: boolean;
    /**
     * The current track in Lavalink's base64 string form
     */
    track: string | null;
    /**
     * The voiceUpdateState of the player, used for swtiching nodes
     */
    voiceUpdateState: PlayerUpdateVoiceState | null;
    /**
     * The constructor of the player
     * @param node The Lavalink of the player
     * @param id the id of the player, aka the guild id
     */
    constructor(node: LavalinkNode, id: string);
    /**
     * Updates the current player on lavalink
     * @param options Update options
     * @param noReplace If the event should be dropped if there's a currently playing track should encodedTrack or identifier be present in options
     */
    update(options: UpdatePlayerData, noReplace?: boolean): Promise<UpdatePlayerResult>;
    /**
     * Plays the specified song using the base64 string from lavalink
     * @param track The base64 string of the song that you want to play
     * @param options Play options
     */
    play(track: string, options?: Omit<UpdatePlayerData, "track"> & {
        noReplace?: boolean;
        userData?: Record<any, any>;
    }): Promise<UpdatePlayerResult>;
    /**
     * Stops the music, depending on how the end event is handled this will either stop
     */
    stop(): Promise<APIPlayer>;
    /**
     * Pauses/Resumes the song depending on what is specified
     * @param pause Whether or not to pause whats currently playing
     */
    pause(pause: boolean): Promise<APIPlayer>;
    /**
     * Resumes the current song
     */
    resume(): Promise<APIPlayer>;
    /**
     * Changes the volume, only for the current song
     * @param volume The volume as a float from 0.0 to 10.0. 1.0 is default.
     */
    volume(volume: number): Promise<APIPlayer>;
    /**
     * Seeks the current song to a certain position
     * @param position Seeks the song to the position specified in milliseconds, use the duration of the song from lavalink to get the duration
     */
    seek(position: number): Promise<APIPlayer>;
    filters(options: Filters): Promise<APIPlayer>;
    /**
     * Sets the equalizer of the current song, if you wanted to do something like bassboost
     * @param bands The bands that you want lavalink to modify read [IMPLEMENTATION.md](https://github.com/lavalink-devs/Lavalink/blob/master/IMPLEMENTATION.md#equalizer) for more information
     */
    equalizer(bands: Equalizer[]): Promise<APIPlayer>;
    /**
     * Sends a destroy signal to lavalink, basically just a cleanup op for lavalink to clean its shit up
     */
    destroy(): Promise<DestroyPlayerResult>;
    /**
     * Sends voiceUpdate information to lavalink so it can connect to discords voice servers properly
     * @param data The data lavalink needs to connect and recieve data from discord
     */
    connect(data: PlayerUpdateVoiceState): Promise<APIPlayer>;
    /**
     * Use this to switch channels
     * @param channel The channel id of the channel you want to switch to
     * @param options selfMute and selfDeaf options
     */
    switchChannel(channel: string, options?: JoinOptions): any;
    /**
     * The manager that created the player
     */
    get manager(): Manager;
}
export interface PlayerEvents {
    event: [EventOP];
    start: [Extract<EventOP, {
        type: "TrackStartEvent";
    }>];
    end: [Extract<EventOP, {
        type: "TrackEndEvent" | "TrackStuckEvent";
    }>];
    pause: [boolean];
    seek: [number];
    error: [Extract<EventOP, {
        type: "TrackExceptionEvent" | "WebSocketClosedEvent";
    }>];
    warn: [string];
    volume: [number];
    playerUpdate: [PlayerUpdate];
    filters: [Filters];
}
export interface Player {
    addListener<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
    emit<E extends keyof PlayerEvents>(event: E, ...args: PlayerEvents[E]): boolean;
    eventNames(): Array<keyof PlayerEvents>;
    listenerCount(event: keyof PlayerEvents): number;
    listeners(event: keyof PlayerEvents): Array<(...args: Array<any>) => any>;
    off<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
    on<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
    once<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
    prependListener<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
    prependOnceListener<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
    rawListeners(event: keyof PlayerEvents): Array<(...args: Array<any>) => any>;
    removeAllListeners(event?: keyof PlayerEvents): this;
    removeListener<E extends keyof PlayerEvents>(event: E, listener: (...args: PlayerEvents[E]) => any): this;
}
