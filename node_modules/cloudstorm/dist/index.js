'use strict';

var events = require('events');
var crypto = require('crypto');
var zlib = require('zlib');
var snowtransfer = require('snowtransfer');
var v10 = require('discord-api-types/v10');

var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty;var __require=(x=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(x,{get:(a,b)=>(typeof require<"u"?require:a)[b]}):x)(function(x){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+x+'" is not supported')});var __esm=(fn,res)=>function(){return fn&&(res=(0, fn[__getOwnPropNames(fn)[0]])(fn=0)),res};var __commonJS=(cb,mod)=>function(){return mod||(0, cb[__getOwnPropNames(cb)[0]])((mod={exports:{}}).exports,mod),mod.exports};var __export=(target,all2)=>{for(var name in all2)__defProp(target,name,{get:all2[name],enumerable:!0});},__copyProps=(to,from,except,desc)=>{if(from&&typeof from=="object"||typeof from=="function")for(let key of __getOwnPropNames(from))!__hasOwnProp.call(to,key)&&key!==except&&__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to};var __toESM=(mod,isNodeMode,target)=>(target=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:!0}):target,mod)),__toCommonJS=mod=>__copyProps(__defProp({},"__esModule",{value:!0}),mod);var require_Constants=__commonJS({"src/Constants.ts"(exports,module){var Constants2={GATEWAY_OP_CODES:{DISPATCH:0,HEARTBEAT:1,IDENTIFY:2,PRESENCE_UPDATE:3,VOICE_STATE_UPDATE:4,RESUME:6,RECONNECT:7,REQUEST_GUILD_MEMBERS:8,INVALID_SESSION:9,HELLO:10,HEARTBEAT_ACK:11},GATEWAY_VERSION:10};module.exports=Constants2;}});var require_BetterWs=__commonJS({"src/BetterWs.ts"(exports,module){var import_Constants=__toESM(require_Constants()),https=__require("https"),http=__require("http"),util=__require("util"),BetterWs=class extends events.EventEmitter{constructor(address,options){super();this.address=address;this.options=options;this.wsBucket=new snowtransfer.LocalBucket(120,6e4);this.presenceBucket=new snowtransfer.LocalBucket(5,6e4);this._socket=null;this._internal={openRejector:null,closePromise:null,zlib:null};this._connecting=!1;this._lastCloseCode=null;this._lastCloseReason=null;this.encoding=options.encoding??"other",this.compress=options.compress??!1;}get status(){let internal=this._internal;return this._connecting?2:internal.closePromise?3:this._socket?1:4}connect(){if(this._socket||this._connecting)return Promise.resolve(void 0);this._connecting=!0;let key=crypto.randomBytes(16).toString("base64"),url=new URL(this.address),useHTTPS=url.protocol==="https:"||url.protocol==="wss:"||url.port==="443",port=url.port||(useHTTPS?"443":"80"),req=(useHTTPS?https:http).request({hostname:url.hostname,path:`${url.pathname}${url.search}`,port,headers:{Connection:"Upgrade",Upgrade:"websocket","Sec-WebSocket-Key":key,"Sec-WebSocket-Version":"13",...this.options.headers}}),onErrorRef,cameFromOnError=!1;return new Promise((resolve2,reject)=>{this._internal.openRejector=reject;let upgrade=this._onUpgrade.bind(this,key,req,resolve2,reject);onErrorRef=e=>{this._internal.openRejector=null,cameFromOnError=!0,this._connecting=!1,req.removeListener("upgrade",upgrade),reject(e);},req.once("upgrade",upgrade),req.once("error",onErrorRef),req.end();}).catch(reason=>(onErrorRef&&!cameFromOnError&&(req.destroy(),req.removeListener("error",onErrorRef),onErrorRef(reason)),Promise.reject(reason)))}async close(code,reason){let internal=this._internal;if(internal.closePromise)return internal.closePromise;if(!this._socket)return Promise.resolve(void 0);let resolver,promise=new Promise(resolve2=>{resolver=resolve2;let from=Buffer.from([code>>8,code&255]);this._write(reason?Buffer.concat([from,Buffer.from(reason)]):from,8);}).then(()=>{internal.closePromise=null;});return promise.resolve=resolver,internal.closePromise=promise,promise}sendMessage(data){return new Promise(res=>{let presence=(data==null?void 0:data.op)===import_Constants.GATEWAY_OP_CODES.PRESENCE_UPDATE,sendMsg=()=>{let fn=()=>{this.emit("ws_send",data),this.encoding==="json"?this._write(Buffer.from(JSON.stringify(data)),1):this.encoding==="etf"?this._write(writeETF(data),2):this.encoding==="other"&&this._write(Buffer.from(data),2),res(void 0);};this.options.bypassBuckets?fn():this.wsBucket.queue(fn);};presence&&!this.options.bypassBuckets?this.presenceBucket.queue(sendMsg):sendMsg();})}_write(packet,opcode){let socket=this._socket;if(!(socket!=null&&socket.writable))return;let length=packet.length,frame;length<126?(frame=Buffer.allocUnsafe(6+length),frame[1]=128+length):length<65536?(frame=Buffer.allocUnsafe(8+length),frame[1]=254,frame[2]=length>>8,frame[3]=length&255):(frame=Buffer.allocUnsafe(14+length),frame[1]=255,frame.writeBigUInt64BE(BigInt(length),2)),frame[0]=128+opcode,frame.writeUInt32BE(0,frame.length-length-4),frame.set(packet,frame.length-length),socket.write(frame);}_onUpgrade(key,req,resolve2,reject,res,socket){this._internal.openRejector=null;let hash=crypto.createHash("sha1").update(key+"258EAFA5-E914-47DA-95CA-C5AB0DC85B11").digest("base64"),accept=res.headers["sec-websocket-accept"];if(hash!==accept){socket.end(()=>{this.emit("debug","Failed websocket-key validation"),this._connecting=!1,reject(new Error(`Invalid Sec-Websocket-Accept | expected: ${hash} | received: ${accept}`));});return}if(socket.once("error",this._onError.bind(this)),socket.once("close",this._onClose.bind(this)),socket.on("readable",this._onReadable.bind(this)),this._socket=socket,this._connecting=!1,this.compress){let z=zlib.createInflate();z._c=z.close,z._h=z._handle,z._hc=z._handle.close,z._v=()=>{},this._internal.zlib=z;}this.emit("ws_open"),resolve2(void 0),req.removeAllListeners("error");}_onError(error){this._socket&&(this.emit("debug",util.inspect(error,!0,1,!1)),this._write(Buffer.allocUnsafe(0),8));}_onClose(){let socket=this._socket,internal=this._internal;socket&&(socket.removeListener("data",this._onReadable),socket.removeListener("error",this._onError),this.wsBucket.dropQueue(),this.presenceBucket.dropQueue(),this._socket=null,this.emit("ws_close",this._lastCloseCode??1006,this._lastCloseReason??"Abnormal Closure"),this._lastCloseCode=null,this._lastCloseReason=null,internal.zlib&&(internal.zlib.close(),internal.zlib=null),internal.closePromise&&internal.closePromise.resolve(void 0));}_onReadable(){let socket=this._socket;for(;((socket==null?void 0:socket.readableLength)||0)>1;){let length=readRange(socket,1,1)&127,bytes=0;if(length>125){if(bytes=length===126?2:8,socket.readableLength<2+bytes)return;length=readRange(socket,2,bytes);}let frame=socket.read(2+bytes+length);if(!frame)return;let fin=frame[0]>>7,opcode=frame[0]&15;(fin!==1||opcode===0)&&this.emit("debug","discord actually does send messages with fin=0. if you see this error let me know");let payload=frame.subarray(2+bytes);this._processFrame(opcode,payload);}}_processFrame(opcode,message){let internal=this._internal;switch(opcode){case 1:{let packet;this.encoding==="json"?packet=JSON.parse(message.toString()):this.encoding==="other"&&(packet=message),this.emit("ws_receive",packet);break}case 2:{let packet;if(this.compress){let z=internal.zlib,error=null,data=null;z.close=z._handle.close=z._v;try{data=z._processChunk(message,zlib.constants.Z_SYNC_FLUSH);}catch(e){error=e;}let l=message.length;if((message[l-4]!==0||message[l-3]!==0||message[l-2]!==255||message[l-1]!==255)&&this.emit("debug","discord actually does send fragmented zlib messages. If you see this error let me know"),z.close=z._c,z._handle=z._h,z._handle.close=z._hc,z._events.error=void 0,z._eventCount--,z.removeAllListeners("error"),error){this.emit("debug","Zlib error processing chunk"),this._write(Buffer.allocUnsafe(0),8);return}if(!data){this.emit("debug","Data from zlib processing was null. If you see this error let me know");return}this.encoding==="json"?packet=JSON.parse(String(data)):this.encoding==="etf"?packet=readETF(data,1):this.encoding==="other"&&(packet=data);}else this.encoding==="json"?packet=JSON.parse(zlib.inflateSync(message).toString()):this.encoding==="etf"?packet=readETF(message,1):this.encoding==="other"&&(packet=message);this.emit("ws_receive",packet);break}case 8:{this._lastCloseCode=message.length>1?(message[0]<<8)+message[1]:0,this._lastCloseReason=message.length>2?message.subarray(2).toString():"",this._write(Buffer.from([this._lastCloseCode>>8,this._lastCloseCode&255]),8);break}case 9:{this._write(message,10);break}}}};function readRange(socket,index,bytes){let cursor=0,read=0,num=0,readable=socket._readableState,currentBufferIndex=readable.bufferIndex,currentBuffer=readable.buffer.head??readable.buffer[currentBufferIndex];do{let data=currentBuffer.data??currentBuffer;for(let element of data)if(++cursor>index&&(num*=256,num+=element,++read===bytes))return num}while(currentBuffer=currentBuffer.next??readable.buffer[++currentBufferIndex]);throw new Error("readRange failed?")}function readETF(data,start){let view,x=start,loop=()=>{let type=data[x++];switch(type){case 97:return data[x++];case 98:{let int=data.readInt32BE(x);return x+=4,int}case 100:{let length=data.readUInt16BE(x),atom="";if(length>30)atom=data.latin1Slice(x+=2,x+length);else for(let i=x+=2;i<x+length;i++)atom+=String.fromCharCode(data[i]);return x+=length,atom?atom==="nil"||atom==="null"?null:atom==="true"?!0:atom==="false"?!1:atom:void 0}case 108:case 106:{let array=[];if(type===108){let length=data.readUInt32BE(x);x+=4;for(let i=0;i<length;i++)array.push(loop());x++;}return array}case 107:{let array=[],length=data.readUInt16BE(x);x+=2;for(let i=0;i<length;i++)array.push(data[x++]);return array}case 109:{let length=data.readUInt32BE(x),str="";if(length>30)str=data.utf8Slice(x+=4,x+length);else {let i=x+=4,l=x+length;for(;i<l;){let byte=data[i++];byte<128?str+=String.fromCharCode(byte):byte<224?str+=String.fromCharCode(((byte&31)<<6)+(data[i++]&63)):byte<240?str+=String.fromCharCode(((byte&15)<<12)+((data[i++]&63)<<6)+(data[i++]&63)):str+=String.fromCodePoint(((byte&7)<<18)+((data[i++]&63)<<12)+((data[i++]&63)<<6)+(data[i++]&63));}}return x+=length,str}case 110:{view||(view=new DataView(data.buffer,data.offset,data.byteLength));let length=data[x++],sign=data[x++],left=length,num=BigInt(0);for(;left>0;)left>=8?(num<<=BigInt(64),num+=view.getBigUint64(x+(left-=8),!0)):left>=4?(num<<=BigInt(32),num+=BigInt(view.getUint32(x+(left-=4)),!0)):left>=2?(num<<=BigInt(16),num+=BigInt(view.getUint16(x+(left-=2)),!0)):(num<<=BigInt(8),num+=BigInt(data[x]),left--);return x+=length,(sign?-num:num).toString()}case 116:{let obj={},length=data.readUInt32BE(x);x+=4;for(let i=0;i<length;i++){let key=loop();obj[key]=loop();}return obj}}throw new Error(`Missing etf type: ${type}`)};return loop()}function writeETF(data){let b=Buffer.allocUnsafe(4096);b[0]=131;let i=1,loop=obj=>{switch(typeof obj){case"boolean":{b[i++]=100,obj?(b.writeUInt16BE(4,i),b.latin1Write("true",i+=2),i+=4):(b.writeUInt16BE(5,i),b.latin1Write("false",i+=2),i+=5);break}case"string":{let length=Buffer.byteLength(obj);b[i++]=109,b.writeUInt32BE(length,i),b.utf8Write(obj,i+=4),i+=length;break}case"number":{if(Number.isInteger(obj)){let abs=Math.abs(obj);if(abs<2147483648)b[i++]=98,b.writeInt32BE(obj,i),i+=4;else if(abs<Number.MAX_SAFE_INTEGER){b[i++]=110,b[i++]=8,b[i++]=+(obj<0),b.writeBigUInt64LE(BigInt(abs),i),i+=8;break}else b[i++]=70,b.writeDoubleBE(obj,i),i+=8;}else b[i++]=70,b.writeDoubleBE(obj,i),i+=8;break}case"bigint":{b[i++]=110,b[i++]=8,b[i++]=+(obj<0),b.writeBigUInt64LE(obj,i),i+=8;break}case"object":{if(obj===null)b[i++]=100,b.writeUInt16BE(3,i),b.latin1Write("nil",i+=2),i+=3;else if(Array.isArray(obj)){if(obj.length){b[i++]=108,b.writeUInt32BE(obj.length,i),i+=4;for(let item of obj)loop(item);}b[i++]=106;}else {let entries=Object.entries(obj).filter(x=>typeof x[1]<"u");b[i++]=116,b.writeUInt32BE(entries.length,i),i+=4;for(let[key,value]of entries)loop(key),loop(value);}break}}};return loop(data),Buffer.from(b.subarray(0,i))}module.exports=BetterWs;}});var Intents_exports={};__export(Intents_exports,{all:()=>all,default:()=>Intents_default,flags:()=>flags,non_privileged:()=>non_privileged,privileged:()=>privileged,resolve:()=>resolve});function resolve(bit=0){if(typeof bit=="number"&&bit>=0)return bit;if(typeof bit=="string"&&flags[bit])return flags[bit]|0;if(Array.isArray(bit))return bit.map(p=>resolve(p)).reduce((prev,p)=>prev|p,0);throw new RangeError("BITFIELD_INVALID")}var flags,privileged,all,non_privileged,Intents_default,init_Intents=__esm({"src/Intents.ts"(){flags={GUILDS:1,GUILD_MEMBERS:2,GUILD_MODERATION:4,GUILD_EMOJIS_AND_STICKERS:8,GUILD_INTEGRATIONS:16,GUILD_WEBHOOKS:32,GUILD_INVITES:64,GUILD_VOICE_STATES:128,GUILD_PRESENCES:256,GUILD_MESSAGES:512,GUILD_MESSAGE_REACTIONS:1024,GUILD_MESSAGE_TYPING:2048,DIRECT_MESSAGES:4096,DIRECT_MESSAGE_REACTIONS:8192,DIRECT_MESSAGE_TYPING:16384,MESSAGE_CONTENT:32768,GUILD_SCHEDULED_EVENTS:65536,AUTO_MODERATION_CONFIGURATION:1048576,AUTO_MODERATION_EXECUTION:2097152},privileged=flags.GUILD_MEMBERS|flags.GUILD_PRESENCES|flags.MESSAGE_CONTENT,all=Object.values(flags).reduce((acc,p)=>acc|p,0),non_privileged=all&~privileged;Intents_default={flags,privileged,all,non_privileged,resolve};}});var require_DiscordConnector=__commonJS({"src/DiscordConnector.ts"(exports,module){var import_Constants=__toESM(require_Constants()),BetterWs=require_BetterWs(),Intents2=(init_Intents(),__toCommonJS(Intents_exports)),resumableCodes=[4008,4005,4003,4002,4001,4e3,1006,1001],shouldntAttemptReconnectCodes=[4014,4013,4012,4011,4010,4004],disconnectMessages={4014:"Disallowed Intents, check your client options and application page.",4013:"Invalid Intents data, check your client options.",4012:"Invalid API version.",4011:"Shard would be on over 2500 guilds. Add more shards.",4010:"Invalid sharding data, check your client options.",4009:"Session timed out.",4008:"You are being rate limited. Wait before sending more packets.",4007:"Invalid sequence. Reconnecting and starting a new session.",4005:"You sent more than one OP 2 IDENTIFY payload while the websocket was open.",4004:"Tried to connect with an invalid token.",4003:"You tried to send a packet before sending an OP 2 IDENTIFY or OP 6 RESUME.",4002:"You sent an invalid payload.",4001:"You sent an invalid opcode or invalid payload for an opcode."},connectionError=new Error("WS took too long to connect. Is your internet okay?"),wsStatusTypes=["Whatever 0 is. Report if you see this","connected","connecting","closing","closed"],DiscordConnector=class extends events.EventEmitter{constructor(id,client){super();this.id=id;this.client=client;this.heartbeatTimeout=null;this.heartbeatInterval=0;this._trace=null;this.seq=0;this.status="disconnected";this.sessionId=null;this.lastACKAt=0;this.lastHeartbeatSend=0;this.latency=0;this.resumeAddress=null;this.reconnecting=!1;this._closing=!1;this._closeCalled=!1;this._openToHeartbeatTimeout=null;this._initialHeartbeatTimeout=null;this.options=client.options,this.reconnect=this.options.reconnect??!0,this.identifyAddress=this.options.endpoint,this.betterWs=new BetterWs(this.identifyAddress,this.options.ws),this.betterWs.on("ws_open",()=>{this.status="connecting",this.emit("stateChange","connecting"),this.reconnecting=!1,this._openToHeartbeatTimeout=setTimeout(()=>{this.client.emit("debug",`Shard ${this.id} didn't receive a HELLO after the ws was opened in time`),this._reconnect(!0);},1e4);}),this.betterWs.on("ws_receive",msg=>this.messageAction(msg)),this.betterWs.on("ws_close",(code,reason)=>this.handleWsClose(code,reason)),this.betterWs.on("debug",event=>this.client.emit("error",event)),this.betterWs.on("ws_send",data=>this.client.emit("rawSend",data));}async connect(){return this._closing=!1,this._closeCalled=!1,this.client.emit("debug",`Shard ${this.id} connecting to gateway`),this.betterWs.connect().catch(e=>{e!==connectionError&&setTimeout(()=>{this._closeCalled||this.connect();},5e3);})}async disconnect(){return this._closing=!0,this._closeCalled=!0,this.betterWs.close(1e3,"Disconnected by User")}async messageAction(message){this.client.emit("rawReceive",message);let withShardID=Object.assign(message,{shard_id:this.id});switch(this.client.emit("event",withShardID),withShardID.op){case import_Constants.GATEWAY_OP_CODES.DISPATCH:this.handleDispatch(withShardID);break;case import_Constants.GATEWAY_OP_CODES.HEARTBEAT:this.heartbeat();break;case import_Constants.GATEWAY_OP_CODES.RECONNECT:this.client.emit("debug",`Gateway asked shard ${this.id} to reconnect`),this.reconnect?this._reconnect(!0):this.disconnect();break;case import_Constants.GATEWAY_OP_CODES.INVALID_SESSION:this.client.emit("debug",`Shard ${this.id}'s session was invalidated`),withShardID.d&&this.sessionId?this.resume():(this.seq=0,this.sessionId="",this.emit("queueIdentify",this.id));break;case import_Constants.GATEWAY_OP_CODES.HELLO:this._openToHeartbeatTimeout&&clearTimeout(this._openToHeartbeatTimeout),this.client.emit("debug",`Shard ${this.id} received HELLO`),this.lastACKAt=Date.now(),this.heartbeatInterval=withShardID.d.heartbeat_interval,this._initialHeartbeatTimeout=setTimeout(()=>this.heartbeat(),this.heartbeatInterval*Math.random()),this._trace=withShardID.d._trace,this._onHello();break;case import_Constants.GATEWAY_OP_CODES.HEARTBEAT_ACK:this.lastACKAt=Date.now(),this.latency=this.lastACKAt-this.lastHeartbeatSend;break;}}async _reconnect(resume=!1){var _a,_b;(_b=(_a=this.betterWs._internal).openRejector)==null||_b.call(_a,connectionError),this.reconnecting=resume,await this.betterWs.close(resume?4e3:1012,"reconnecting"),resume?(this.clearHeartBeat(),this.resumeAddress?this.betterWs.address=this.resumeAddress:this.betterWs.address=this.identifyAddress):(this.reset(),this.betterWs.address=this.identifyAddress),this.connect();}reset(){this.sessionId=null,this.seq=0,this.lastACKAt=0,this._trace=null,this.clearHeartBeat();}setHeartBeat(){this.heartbeatTimeout=setInterval(()=>{this.lastACKAt<=Date.now()-(this.heartbeatInterval+5e3)?(this.client.emit("debug",`Shard ${this.id} has not received a heartbeat ACK in ${this.heartbeatInterval+5e3}ms.`),this.reconnect?this._reconnect(!0):this.disconnect()):this.heartbeat();},this.heartbeatInterval);}clearHeartBeat(){this.heartbeatTimeout&&clearInterval(this.heartbeatTimeout),this._initialHeartbeatTimeout&&clearTimeout(this._initialHeartbeatTimeout),this.heartbeatTimeout=null,this._initialHeartbeatTimeout=null,this.heartbeatInterval=0;}_onHello(){if(this.sessionId)return void this.resume();this.emit("queueIdentify",this.id);}async identify(){if(this.betterWs.status!==1)return this.client.emit("error",`Shard ${this.id} was attempting to identify when the ws was not open. Was ${wsStatusTypes[this.betterWs.status]}`),this._reconnect(!0);this.client.emit("debug",`Shard ${this.id} is identifying`),this.status="identifying",this.emit("stateChange","identifying");let data={op:import_Constants.GATEWAY_OP_CODES.IDENTIFY,d:{token:this.options.token,properties:{os:process.platform,browser:"CloudStorm",device:"CloudStorm"},large_threshold:this.options.largeGuildThreshold,shard:[this.id,this.options.totalShards??1],intents:this.options.intents?Intents2.resolve(this.options.intents):0}};return this.options.initialPresence&&(data.d.presence=this._checkPresenceData(this.options.initialPresence)),this.betterWs.sendMessage(data)}async resume(){return this.betterWs.status!==1?(this.client.emit("error",`Shard ${this.id} was attempting to resume when the ws was not open. Was ${wsStatusTypes[this.betterWs.status]}`),this._reconnect(!0)):(this.client.emit("debug",`Shard ${this.id} is resuming`),this.status="resuming",this.emit("stateChange","resuming"),this.betterWs.sendMessage({op:import_Constants.GATEWAY_OP_CODES.RESUME,d:{seq:this.seq,token:this.options.token,session_id:this.sessionId}}))}heartbeat(){if(this.betterWs.status!==1)return this.client.emit("error",`Shard ${this.id} was attempting to heartbeat when the ws was not open. Was ${wsStatusTypes[this.betterWs.status]}`),void this._reconnect(!0);this.betterWs.sendMessage({op:import_Constants.GATEWAY_OP_CODES.HEARTBEAT,d:this.seq===0?null:this.seq}),this.lastHeartbeatSend=Date.now(),this._initialHeartbeatTimeout&&(clearTimeout(this._initialHeartbeatTimeout),this._initialHeartbeatTimeout=null),this.heartbeatTimeout||this.setHeartBeat();}handleDispatch(message){var _a,_b;switch(this.client.emit("dispatch",message),message.s&&(message.s>this.seq+1&&(this.client.emit("debug",`Shard ${this.id} invalid sequence: { current: ${this.seq} message: ${message.s} }`),this.seq=message.s,this.resume()),this.seq=message.s),message.t){case"READY":case"RESUMED":message.t==="READY"&&(message.d.resume_gateway_url&&(this.resumeAddress=`${message.d.resume_gateway_url}?v=${import_Constants.GATEWAY_VERSION}&encoding=${((_a=this.options.ws)==null?void 0:_a.encoding)==="etf"?"etf":"json"}${(_b=this.options.ws)!=null&&_b.compress?"&compress=zlib-stream":""}`),this.sessionId=message.d.session_id),this.status="ready",this.emit("stateChange","ready"),this._trace=message.d._trace,this.emit("ready",message.t==="RESUMED");break;}}handleWsClose(code,reason){let gracefulClose=!1;this.status="disconnected",this.emit("stateChange","disconnected"),this.clearHeartBeat();let isManualClose=code===1e3&&this._closing,message=disconnectMessages[code],isRecoverable=resumableCodes.includes(code),shouldntReconnect=shouldntAttemptReconnectCodes.includes(code)||isManualClose;isRecoverable&&this.resumeAddress?this.betterWs.address=this.resumeAddress:this.betterWs.address=this.identifyAddress,message&&this.client.emit("error",message),(isManualClose||this.reconnecting)&&(gracefulClose=!0),this._closing=!1,this.emit("disconnect",code,reason,gracefulClose),!shouldntReconnect&&this.reconnect&&this.connect();}async presenceUpdate(data){return this.betterWs.sendMessage({op:import_Constants.GATEWAY_OP_CODES.PRESENCE_UPDATE,d:this._checkPresenceData(data)})}async voiceStateUpdate(data){return data?this.betterWs.sendMessage({op:import_Constants.GATEWAY_OP_CODES.VOICE_STATE_UPDATE,d:this._checkVoiceStateUpdateData(data)}):Promise.resolve()}async requestGuildMembers(data){return this.betterWs.sendMessage({op:import_Constants.GATEWAY_OP_CODES.REQUEST_GUILD_MEMBERS,d:this._checkRequestGuildMembersData(data)})}_checkPresenceData(data){if(data.status=data.status??v10.PresenceUpdateStatus.Online,data.activities=data.activities&&Array.isArray(data.activities)?data.activities:[],data.activities)for(let activity of data.activities){let index=data.activities.indexOf(activity);activity.type===void 0&&(activity.type=activity.url?1:0),activity.name||(activity.state&&activity.type===4?activity.name="Custom Status":data.activities.splice(index,1));}return data.afk=data.afk??!1,data.since=data.since??Date.now(),data}_checkVoiceStateUpdateData(data){return data.channel_id=data.channel_id??null,data.self_mute=data.self_mute??!1,data.self_deaf=data.self_deaf??!1,data}_checkRequestGuildMembersData(data){let withQuery=data,withUserIDs=data;return !withQuery.query&&!withUserIDs.user_ids&&(withQuery.query=""),withQuery.query&&withUserIDs.user_ids&&delete data.query,data.limit=data.limit??10,data}};module.exports=DiscordConnector;}});var require_Shard=__commonJS({"src/Shard.ts"(exports,module){var DC=require_DiscordConnector(),Shard=class extends events.EventEmitter{constructor(id,client){super();this.id=id;this.client=client;this.ready=!1;this.connector=new DC(id,client),this.connector.on("disconnect",(...args)=>{this.ready=!1,this.emit("disconnect",...args);}),this.connector.on("ready",resume=>this.emit("ready",resume)),this.connector.on("queueIdentify",()=>this.emit("queueIdentify",this.id));}get latency(){return this.connector.latency}connect(){this.connector.connect();}disconnect(){return this.connector.disconnect()}presenceUpdate(data){return this.connector.presenceUpdate(data)}voiceStateUpdate(data){return this.connector.voiceStateUpdate(data)}requestGuildMembers(data){return this.connector.requestGuildMembers(data)}};module.exports=Shard;}});var require_ShardManager=__commonJS({"src/ShardManager.ts"(exports,module){var Shard=require_Shard(),ShardManager=class{constructor(client){this.client=client;this.shards={};this.identifyBucket=new snowtransfer.LocalBucket(1e3,1e3*60*60*24);this.concurrencyBucket=null;this.options=client.options;}spawn(){if(!this.concurrencyBucket)throw new Error("Trying to spawn shards without calling Client.connect()");for(let id of this.options.shards==="auto"?Array(this.options.totalShards).fill(0).map((_,index)=>index):this.options.shards??[0])this.client.emit("debug",`Spawned shard ${id}`),this.shards[id]=new Shard(id,this.client),this._addListener(this.shards[id]),this.shards[id].connector.connect();}disconnect(){for(let shardKey in this.shards)this.shards[shardKey].disconnect();}_addListener(shard){shard.on("ready",resume=>{shard.ready=!0,this.client.emit("debug",`Shard ${shard.id} ${resume?"has resumed":"is ready"}`),this.client.emit("shardReady",{id:shard.id,ready:!resume}),this._checkReady();}),shard.on("queueIdentify",shardId=>{var _a;if(!this.shards[shardId])return this.client.emit("debug",`Received a queueIdentify event for shard ${shardId} but it does not exist. Was it removed?`);if(this.client.emit("debug",`Shard ${shardId} is ready to identify`),shard.connector.reconnecting)return shard.connector.resume();(_a=this.concurrencyBucket)==null||_a.queue(()=>{this.identifyBucket.queue(()=>this.shards[shardId].connector.identify());});}),shard.on("disconnect",(code,reason,gracefulClose)=>{if(this.client.emit("debug",`Websocket of shard ${shard.id} closed with code ${code} and reason: ${reason??"None"}`),code===1e3&&gracefulClose)return this._checkDisconnect()});}_checkReady(){for(let shardId in this.shards)if(this.shards[shardId]&&!this.shards[shardId].ready)return;this.client.emit("ready");}_checkDisconnect(){for(let shardId in this.shards)if(this.shards[shardId]&&this.shards[shardId].connector.status!=="disconnected")return;this.client.emit("disconnected");}async presenceUpdate(data){for(let shardKey in this.shards)if(this.shards[shardKey]){let shard=this.shards[shardKey];this.shardPresenceUpdate(shard.id,data);}}shardPresenceUpdate(shardId,data){return new Promise((res,rej)=>{let shard=this.shards[shardId];shard||rej(new Error(`Shard ${shardId} does not exist`)),shard.ready&&shard.presenceUpdate(data).then(result=>res(result)).catch(e=>rej(e));})}voiceStateUpdate(shardId,data){return new Promise((res,rej)=>{let shard=this.shards[shardId];shard||rej(new Error(`Shard ${shardId} does not exist`)),shard.ready&&shard.voiceStateUpdate(data).then(result=>res(result)).catch(e=>rej(e));})}requestGuildMembers(shardId,data){return new Promise((res,rej)=>{let shard=this.shards[shardId];shard||rej(new Error(`Shard ${shardId} does not exist`)),shard.ready&&shard.requestGuildMembers(data).then(result=>res(result)).catch(e=>rej(e));})}};module.exports=ShardManager;}});var require_Client=__commonJS({"src/Client.ts"(exports,module){var fs=__require("fs"),path=__require("path"),version=JSON.parse(fs.readFileSync(path.join(__dirname,"../package.json"),{encoding:"utf8"})).version,Constants2=require_Constants(),ShardManager=require_ShardManager(),Client=class extends events.EventEmitter{constructor(token,options={}){super();this.version=version;if(!token)throw new Error("Missing token!");this.options={largeGuildThreshold:250,shards:"auto",reconnect:!0,intents:0,token:"",ws:{compress:!0,encoding:"json"}},this._restClient=options.snowtransferInstance?options.snowtransferInstance:new snowtransfer.SnowTransfer(token),delete options.snowtransferInstance,this.token=token.startsWith("Bot ")?token.substring(4):token,Object.assign(this.options,options),this.options.token=token,this.shardManager=new ShardManager(this);}async connect(){let initial=await this.fetchConnectInfo();this.options.shards==="auto"&&(this.options.totalShards=initial),this.shardManager.spawn();}async fetchConnectInfo(){var _a;let gateway=await this.getGatewayBot();this._updateEndpoint(gateway.url);let oldQueueConcurrency=[],oldQueueIdentify=[];(_a=this.shardManager.concurrencyBucket)!=null&&_a.fnQueue.length&&(oldQueueConcurrency.push(...this.shardManager.concurrencyBucket.fnQueue),this.shardManager.concurrencyBucket.dropQueue()),this.shardManager.identifyBucket.fnQueue.length&&oldQueueIdentify.push(...this.shardManager.identifyBucket.fnQueue),this.shardManager.identifyBucket.dropQueue(),this.shardManager.concurrencyBucket=new snowtransfer.LocalBucket(gateway.session_start_limit.max_concurrency,5e3),this.shardManager.identifyBucket.remaining=gateway.session_start_limit.remaining,this.shardManager.identifyBucket.reset=gateway.session_start_limit.reset_after;for(let fn of oldQueueConcurrency)this.shardManager.concurrencyBucket.queue(fn);for(let fn of oldQueueIdentify)this.shardManager.identifyBucket.queue(fn);return gateway.shards}async getGateway(){return (await this._restClient.bot.getGateway()).url}async getGatewayBot(){return this._restClient.bot.getGatewayBot()}disconnect(){return this.shardManager.disconnect()}async presenceUpdate(data){return this.shardManager.presenceUpdate(data)}shardStatusUpdate(shardId,data){return this.shardManager.shardPresenceUpdate(shardId,data)}voiceStateUpdate(shardId,data){return this.shardManager.voiceStateUpdate(shardId,data)}requestGuildMembers(shardId,data){if(!data.guild_id)throw new Error("You need to pass a guild_id");return this.shardManager.requestGuildMembers(shardId,data)}_updateEndpoint(gatewayUrl){var _a,_b;this.options.endpoint=`${gatewayUrl}?v=${Constants2.GATEWAY_VERSION}&encoding=${((_a=this.options.ws)==null?void 0:_a.encoding)==="etf"?"etf":"json"}${(_b=this.options.ws)!=null&&_b.compress?"&compress=zlib-stream":""}`;}};module.exports=Client;}});var Client2=require_Client(),Constants=require_Constants(),Intents=(init_Intents(),__toCommonJS(Intents_exports)),Shard2=require_Shard(),ShardManager2=require_ShardManager(),BetterWs2=require_BetterWs();

exports.BetterWs = BetterWs2;
exports.Client = Client2;
exports.Constants = Constants;
exports.Intents = Intents;
exports.Shard = Shard2;
exports.ShardManager = ShardManager2;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map