import * as snowtransfer from 'snowtransfer';
import { LocalBucket } from 'snowtransfer';
import { GatewayReceivePayload, GatewayDispatchPayload, GatewayPresenceUpdateData, GatewayVoiceStateUpdateData, GatewayRequestGuildMembersData, APIGatewayBotInfo, GatewaySendPayload } from 'discord-api-types/v10';
import * as events from 'events';
import { EventEmitter } from 'events';
import * as zlib from 'zlib';

type IntentFlags = typeof flags;
type IntentResolvable = number | Array<number> | keyof IntentFlags | Array<keyof IntentFlags>;
/**
 * Bit flags representing Discord intents.
 */
declare const flags: {
    GUILDS: number;
    GUILD_MEMBERS: number;
    GUILD_MODERATION: number;
    GUILD_EMOJIS_AND_STICKERS: number;
    GUILD_INTEGRATIONS: number;
    GUILD_WEBHOOKS: number;
    GUILD_INVITES: number;
    GUILD_VOICE_STATES: number;
    GUILD_PRESENCES: number;
    GUILD_MESSAGES: number;
    GUILD_MESSAGE_REACTIONS: number;
    GUILD_MESSAGE_TYPING: number;
    DIRECT_MESSAGES: number;
    DIRECT_MESSAGE_REACTIONS: number;
    DIRECT_MESSAGE_TYPING: number;
    MESSAGE_CONTENT: number;
    GUILD_SCHEDULED_EVENTS: number;
    AUTO_MODERATION_CONFIGURATION: number;
    AUTO_MODERATION_EXECUTION: number;
};
/**
 * A function to resolve either bit number(s) or human readable string(s) to a bit collection number Discord can accept as client intents.
 * @param bit Data representing intents that can be resolved to a bit collection number Discord can accept.
 * @returns A bit collection number Discord can accept as the client intents.
 */
declare function resolve(bit?: IntentResolvable): number;
declare const _default: {
    flags: {
        GUILDS: number;
        GUILD_MEMBERS: number;
        GUILD_MODERATION: number;
        GUILD_EMOJIS_AND_STICKERS: number;
        GUILD_INTEGRATIONS: number;
        GUILD_WEBHOOKS: number;
        GUILD_INVITES: number;
        GUILD_VOICE_STATES: number;
        GUILD_PRESENCES: number;
        GUILD_MESSAGES: number;
        GUILD_MESSAGE_REACTIONS: number;
        GUILD_MESSAGE_TYPING: number;
        DIRECT_MESSAGES: number;
        DIRECT_MESSAGE_REACTIONS: number;
        DIRECT_MESSAGE_TYPING: number;
        MESSAGE_CONTENT: number;
        GUILD_SCHEDULED_EVENTS: number;
        AUTO_MODERATION_CONFIGURATION: number;
        AUTO_MODERATION_EXECUTION: number;
    };
    privileged: number;
    all: number;
    non_privileged: number;
    resolve: typeof resolve;
};

type IGatewayMessage = GatewayReceivePayload & {
    shard_id: number;
};
type IGatewayDispatch = GatewayDispatchPayload & {
    shard_id: number;
};
interface IClientOptions {
    largeGuildThreshold?: number;
    /**
     * A note on "auto" sharding:
     * "auto" will always start at 0 as there is no way to know the next available shard id.
     * If you have more than one "cluster", you must specify an Array of shard ids. along with totalShards
     */
    shards?: "auto" | Array<number>;
    /**
     * Ignored and overwrote if using "auto" sharding.
     * The total number of shards expected across all clusters.
     */
    totalShards?: number;
    reconnect?: boolean;
    initialPresence?: GatewayPresenceUpdateData;
    intents?: IntentResolvable;
    snowtransferInstance?: snowtransfer.SnowTransfer;
    ws?: IClientWSOptions;
}
interface IClientWSOptions {
    compress?: boolean;
    encoding?: "etf" | "json";
    headers?: Record<string, any>;
    bypassBuckets?: boolean;
}

interface BWSEvents {
    ws_open: [];
    ws_close: [number, string];
    ws_receive: [any];
    ws_send: [any];
    debug: [string];
}
interface BetterWs {
    addListener<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
    emit<E extends keyof BWSEvents>(event: E, ...args: BWSEvents[E]): boolean;
    eventNames(): Array<keyof BWSEvents>;
    listenerCount(event: keyof BWSEvents): number;
    listeners(event: keyof BWSEvents): Array<(...args: Array<any>) => any>;
    off<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
    on<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
    once<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
    prependListener<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
    prependOnceListener<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
    rawListeners(event: keyof BWSEvents): Array<(...args: Array<any>) => any>;
    removeAllListeners(event?: keyof BWSEvents): this;
    removeListener<E extends keyof BWSEvents>(event: E, listener: (...args: BWSEvents[E]) => any): this;
}
/**
 * Helper Class for simplifying the websocket connection to Discord.
 */
declare class BetterWs extends EventEmitter {
    address: string;
    options: Omit<IClientWSOptions, "encoding"> & {
        encoding?: IClientWSOptions["encoding"] | "other";
    };
    /** The encoding to send/receive messages to/from the server with. */
    encoding: "etf" | "json" | "other";
    /** If the messages sent/received are compressed with zlib. */
    compress: boolean;
    /** The ratelimit bucket for how many packets this ws can send within a time frame. */
    wsBucket: LocalBucket;
    /** The ratelimit bucket for how many presence update specific packets this ws can send within a time frame. Is still affected by the overall packet send bucket. */
    presenceBucket: LocalBucket;
    /** The raw net.Socket retreived from upgrading the connection or null if not upgraded/closed. */
    private _socket;
    /** Internal properties that need a funny way to be referenced. */
    _internal: {
        openRejector: ((reason?: any) => void) | null;
        /** A promise that resolves when the connection is fully closed or null if not closing the connection if any. */
        closePromise: Promise<void> | null;
        /** A zlib Inflate instance if messages sent/received are going to be compressed. Auto created on connect. */
        zlib: zlib.Inflate | null;
    };
    /** If a request is going through to initiate a WebSocket connection and hasn't been upgraded by the server yet. */
    private _connecting;
    /** Code received from frame op 8 */
    private _lastCloseCode;
    /** Reason received from frame op 8 */
    private _lastCloseReason;
    /**
     * Creates a new lightweight WebSocket.
     * @param address The http(s):// or ws(s):// URL cooresponding to the server to connect to.
     * @param options Options specific to this WebSocket.
     */
    constructor(address: string, options: Omit<IClientWSOptions, "encoding"> & {
        encoding?: IClientWSOptions["encoding"] | "other";
    });
    /**
     * The state this WebSocket is in. 1 is connected, 2 is connecting, 3 is closing, and 4 is closed.
     */
    get status(): 1 | 2 | 3 | 4;
    /**
     * Initiates a WebSocket connection to the server.
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the server.
     * @param code The close code.
     * @param reason The reason for closing if any.
     * @returns A Promise that resolves when the connection is fully closed.
     */
    close(code: number, reason?: string): Promise<void>;
    /**
     * Sends a message to the server in the format of { op: number, d: any } (before any encoding/compression).
     * @param data What to send to the server.
     * @returns A Promise that resolves when the message passes the bucket queue(s) and is written to the socket's Buffer to send.
     */
    sendMessage(data: any): Promise<void>;
    /**
     * Method to raw write messages to the server.
     * @param packet Buffer containing the message to send.
     * @param opcode WebSocket spec op code.
     */
    private _write;
    /**
     * Handler for when requests from connect are upgraded to WebSockets.
     * @param key The sec key from connect.
     * @param req The HTTP request from connect.
     * @param resolve Promise resolver from connect.
     * @param reject Promise rejector from connect.
     * @param res The HTTP response from the server from connect.
     * @param socket The raw socket from upgrading the request from connect.
     */
    private _onUpgrade;
    /**
     * Handler for when the raw socket to the server encounters an error.
     * @param error What happened.
     */
    private _onError;
    /**
     * Handler for when the raw socket is fully closed and cleans up this WebSocket.
     */
    private _onClose;
    /**
     * Handler for when there is data in the socket's Buffer to read.
     */
    private _onReadable;
    /**
     * Transforms/reads raw messages from the server and emits the appropriate event.
     * @param opcode WebSocket spec op code.
     * @param message Buffer of data to transform/read.
     */
    private _processFrame;
}

interface ConnectorEvents {
    queueIdentify: [number];
    ready: [boolean];
    disconnect: [number, string, boolean];
    stateChange: ["connecting" | "identifying" | "resuming" | "ready" | "disconnected"];
}
interface DiscordConnector {
    addListener<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
    emit<E extends keyof ConnectorEvents>(event: E, ...args: ConnectorEvents[E]): boolean;
    eventNames(): Array<keyof ConnectorEvents>;
    listenerCount(event: keyof ConnectorEvents): number;
    listeners(event: keyof ConnectorEvents): Array<(...args: Array<any>) => any>;
    off<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
    on<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
    once<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
    prependListener<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
    prependOnceListener<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
    rawListeners(event: keyof ConnectorEvents): Array<(...args: Array<any>) => any>;
    removeAllListeners(event?: keyof ConnectorEvents): this;
    removeListener<E extends keyof ConnectorEvents>(event: E, listener: (...args: ConnectorEvents[E]) => any): this;
}
/**
 * Class used for acting based on received events.
 *
 * This class is automatically instantiated by the library and is documented for reference.
 */
declare class DiscordConnector extends EventEmitter {
    id: number;
    client: EventEmitter & {
        options: Omit<IClientOptions, "snowtransferInstance"> & {
            token: string;
            endpoint?: string;
        };
    };
    /** The options used by the client */
    options: DiscordConnector["client"]["options"];
    /** If this connector will attempt to automatically reconnect */
    reconnect: boolean;
    /** The WebSocket this connector uses */
    betterWs: BetterWs;
    /** A Timeout that, when triggered, will send an op 1 heartbeat. Is null if Discord hasn't told this connector how often to heartbeat */
    heartbeatTimeout: NodeJS.Timeout | null;
    /** How often this connector should heartbeat if not 0 */
    heartbeatInterval: number;
    /** The _trace as sent by the Discord READY and RESUMED payloads */
    _trace: string | null;
    /** The sequence, which is the number of events received by Discord within the session if any session */
    seq: number;
    /** The status of this connector */
    status: "connecting" | "identifying" | "resuming" | "ready" | "disconnected";
    /** The session ID used for resuming or null if Discord hasn't sent one yet */
    sessionId: string | null;
    /** The ms timestamp when this connector last received an op 11 heartbeat ack if not 0 */
    lastACKAt: number;
    /** The ms timestamp when this connector last sent an op 1 heartbeat if not 0 */
    lastHeartbeatSend: number;
    /** The time in milliseconds it took for Discord to send an op 11 heartbeat ack in response to an op 1 heartbeat */
    latency: number;
    /** The address the WebSocket will use to connect to the Discord gateway if not resuming */
    identifyAddress: string;
    /** The address the WebSocket will use to connect to the Discord gateway if resuming */
    resumeAddress: string | null;
    /** If this connector is disconnected/disconnecting currently, but will reconnect eventually */
    reconnecting: boolean;
    /** If this connector is waiting to be fully closed */
    private _closing;
    /** If the disconnect method on this class was called and the connect method hasn't been called yet */
    private _closeCalled;
    /** A Timeout that, when triggered, closes the connection because op HELLO hasn't been received and may never be received */
    private _openToHeartbeatTimeout;
    /** A Timeout that, when triggered, sends the first heartbeat */
    private _initialHeartbeatTimeout;
    /**
     * Creates a new Discord Connector.
     * @param id id of the shard that created this class.
     * @param client Main client instance.
     */
    constructor(id: number, client: EventEmitter & {
        options: Omit<IClientOptions, "snowtransferInstance"> & {
            token: string;
            endpoint?: string;
        };
    });
    /**
     * Connect to Discord.
     */
    connect(): Promise<void>;
    /**
     * Close the websocket connection and disconnect.
     */
    disconnect(): Promise<void>;
    /**
     * Called with a parsed Websocket message to execute further actions.
     * @param message Message that was received.
     */
    private messageAction;
    /**
     * Reset this connector to be ready to resume or hard reconnect, then connect.
     * @param resume Whether or not the client intends to send an OP 6 RESUME later.
     */
    private _reconnect;
    /**
     * Hard reset this connector.
     */
    private reset;
    /**
     * Sets the this.heartbeatTimeout Interval.
     */
    private setHeartBeat;
    /**
     * Clear the heart beat interval, set it to null and set the cached heartbeat_interval as 0.
     */
    private clearHeartBeat;
    private _onHello;
    /**
     * Send an OP 2 IDENTIFY to the gateway.
     */
    identify(): Promise<void>;
    /**
     * Send an OP 6 RESUME to the gateway.
     */
    resume(): Promise<void>;
    /**
     * Send an OP 1 HEARTBEAT to the gateway.
     */
    private heartbeat;
    /**
     * Handle dispatch events.
     * @param message Message received from the websocket.
     */
    private handleDispatch;
    /**
     * Handle a close from the underlying websocket.
     * @param code Websocket close code.
     * @param reason Close reason if any.
     */
    private handleWsClose;
    /**
     * Send an OP 3 PRESENCE_UPDATE to the gateway.
     * @param data Presence data to send.
     */
    presenceUpdate(data: Partial<GatewayPresenceUpdateData>): Promise<void>;
    /**
     * Send an OP 4 VOICE_STATE_UPDATE to the gateway.
     * @param data Voice state update data to send.
     */
    voiceStateUpdate(data: GatewayVoiceStateUpdateData & {
        self_deaf?: boolean;
        self_mute?: boolean;
    }): Promise<void>;
    /**
     * Send an OP 8 REQUEST_GUILD_MEMBERS to the gateway.
     * @param data Data to send.
     */
    requestGuildMembers(data: GatewayRequestGuildMembersData & {
        limit?: number;
    }): Promise<void>;
    /**
     * Checks presence data and fills in missing elements.
     * @param data Data to send.
     * @returns Data after it's fixed/checked.
     */
    private _checkPresenceData;
    /**
     * Checks voice state update data and fills in missing elements.
     * @param data Data to send.
     * @returns Data after it's fixed/checked.
     */
    private _checkVoiceStateUpdateData;
    /**
     * Checks request guild members data and fills in missing elements.
     * @param data Data to send.
     * @returns Data after it's fixed/checked.
     */
    private _checkRequestGuildMembersData;
}

interface ShardEvents {
    disconnect: [number, string, boolean];
    ready: [boolean];
    queueIdentify: [number];
}
interface Shard {
    addListener<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
    emit<E extends keyof ShardEvents>(event: E, ...args: ShardEvents[E]): boolean;
    eventNames(): Array<keyof ShardEvents>;
    listenerCount(event: keyof ShardEvents): number;
    listeners(event: keyof ShardEvents): Array<(...args: Array<any>) => any>;
    off<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
    on<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
    once<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
    prependListener<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
    prependOnceListener<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
    rawListeners(event: keyof ShardEvents): Array<(...args: Array<any>) => any>;
    removeAllListeners(event?: keyof ShardEvents): this;
    removeListener<E extends keyof ShardEvents>(event: E, listener: (...args: ShardEvents[E]) => any): this;
}
/**
 * Shard class, which provides a wrapper around the DiscordConnector with metadata like the id of the shard.
 *
 * This class is automatically instantiated by the library and is documented for reference.
 */
declare class Shard extends EventEmitter {
    id: number;
    client: EventEmitter & {
        options: Omit<IClientOptions, "snowtransferInstance"> & {
            token: string;
            endpoint?: string;
        };
    };
    /** If this shard has received the READY or RESUMED payload and isn't disconnected yet. */
    ready: boolean;
    /** The connector that handles all of the Discord specific connection logic. */
    connector: DiscordConnector;
    /**
     * Create a new Shard.
     * @param id id of the shard.
     * @param client Main class used for forwarding events.
     */
    constructor(id: number, client: EventEmitter & {
        options: Omit<IClientOptions, "snowtransferInstance"> & {
            token: string;
            endpoint?: string;
        };
    });
    /**
     * Time in ms it took for Discord to ackknowledge an OP 1 HEARTBEAT.
     */
    get latency(): number;
    /**
     * Create a new connection to Discord.
     */
    connect(): void;
    /**
     * Close the current connection to Discord.
     */
    disconnect(): Promise<void>;
    /**
     * Send an OP 3 PRESENCE_UPDATE to Discord.
     * @param data Data to send.
     */
    presenceUpdate(data: Parameters<Shard["connector"]["presenceUpdate"]>["0"]): Promise<void>;
    /**
     * Send an OP 4 VOICE_STATE_UPDATE to Discord.
     * @param data Data to send
     */
    voiceStateUpdate(data: Parameters<Shard["connector"]["voiceStateUpdate"]>["0"]): Promise<void>;
    /**
     * Send an OP 8 REQUEST_GUILD_MEMBERS to Discord.
     * @param data Data to send.
     */
    requestGuildMembers(data: Parameters<Shard["connector"]["requestGuildMembers"]>["0"]): Promise<void>;
}

/**
 * Class used for managing shards for the user.
 *
 * This class is automatically instantiated by the library and is documented for reference.
 */
declare class ShardManager {
    client: events.EventEmitter & {
        options: Omit<IClientOptions, "snowtransferInstance"> & {
            token: string;
            endpoint?: string;
        };
    };
    /** The options used by the client */
    options: ShardManager["client"]["options"];
    /** A Record of shards keyed by their ID */
    shards: {
        [id: number]: Shard;
    };
    /** The bucket used to identify a certain number of shards within a day. */
    identifyBucket: LocalBucket;
    /** The bucket used to identify x number of shards within 5 second intervals. Larger bots benefit from this, but doesn't change how many times per day any shards can identify. */
    concurrencyBucket: LocalBucket | null;
    /**
     * Create a new ShardManager.
     */
    constructor(client: events.EventEmitter & {
        options: Omit<IClientOptions, "snowtransferInstance"> & {
            token: string;
            endpoint?: string;
        };
    });
    /**
     * Create shard instances and add them to the connection queue.
     */
    spawn(): void;
    /**
     * Disconnect all shards facilitated by this manager.
     */
    disconnect(): void;
    /**
     * Add event listeners to a shard to that the manager can act on received events.
     * @param shard Shard to add the event listeners to.
     */
    private _addListener;
    /**
     * Checks if all shards spawned by this manager are ready.
     */
    private _checkReady;
    /**
     * Checks if all shards spawned by this manager are disconnected.
     */
    private _checkDisconnect;
    /**
     * Update the status of all currently connected shards which have been spawned by this manager.
     * @param data Data to send.
     */
    presenceUpdate(data: Parameters<Shard["presenceUpdate"]>["0"]): Promise<void>;
    /**
     * Update the status of a single connected shard which has been spawned by this manager.
     * @param shardId id of the shard.
     * @param data Data to send.
     */
    shardPresenceUpdate(shardId: number, data: Parameters<Shard["presenceUpdate"]>["0"]): Promise<void>;
    /**
     * Send an OP 4 VOICE_STATE_UPDATE with a certain shard.
     * @param shardId id of the shard.
     * @param data Data to send.
     */
    voiceStateUpdate(shardId: number, data: Parameters<Shard["voiceStateUpdate"]>["0"]): Promise<void>;
    /**
     * Send an OP 8 REQUEST_GUILD_MEMBERS with a certain shard.
     * @param shardId id of the shard.
     * @param data Data to send.
     */
    requestGuildMembers(shardId: number, data: Parameters<Shard["requestGuildMembers"]>["0"]): Promise<void>;
}

interface ClientEvents {
    debug: [string];
    rawSend: [GatewaySendPayload];
    rawReceive: [GatewayReceivePayload];
    error: [string];
    event: [IGatewayMessage];
    dispatch: [IGatewayDispatch];
    shardReady: [{
        id: number;
        ready: boolean;
    }];
    ready: [];
    disconnected: [];
}
interface Client {
    addListener<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
    emit<E extends keyof ClientEvents>(event: E, ...args: ClientEvents[E]): boolean;
    eventNames(): Array<keyof ClientEvents>;
    listenerCount(event: keyof ClientEvents): number;
    listeners(event: keyof ClientEvents): Array<(...args: Array<any>) => any>;
    off<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
    on<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
    once<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
    prependListener<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
    prependOnceListener<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
    rawListeners(event: keyof ClientEvents): Array<(...args: Array<any>) => any>;
    removeAllListeners(event?: keyof ClientEvents): this;
    removeListener<E extends keyof ClientEvents>(event: E, listener: (...args: ClientEvents[E]) => any): this;
}
/**
 * Main class used for receiving events and interacting with the Discord gateway.
 */
declare class Client extends EventEmitter {
    /** The Discord auth token to connect with. */
    token: string;
    /** User specific options filled in with defaults if not specified. */
    options: Omit<IClientOptions, "snowtransferInstance"> & {
        token: string;
        endpoint?: string;
    };
    /** The manager of all of the shards used to connect to Discord. */
    shardManager: ShardManager;
    /** The version string of CloudStorm. */
    version: string;
    /** The SnowTransfer instance to use to make some requests to get connect info. */
    private _restClient;
    /**
     * Create a new Client to connect to the Discord gateway.
     * @param token Token received from creating a discord bot user, which will be used to connect to the gateway.
     * @param options Baseline options to use. Will be filled with defaults if not specified.
     */
    constructor(token: string, options?: IClientOptions);
    /**
     * Create one or more connections (depending on the selected amount of shards) to the Discord gateway.
     * @returns This function returns a promise which is solely used for awaiting the getGateway() method's return value.
     */
    connect(): Promise<void>;
    /**
     * Method to grab initial connection info from Discord.
     * Should only be called automatically by the lib unless you are a large bot with a max_concurrency not equal to 1.
     * If you are a large bot, you should call this method at a rate of your own discretion to update your max_concurrency cached value to have up to date bucket info.
     * @returns The amount of shards the bot should spawn if set to auto.
     */
    fetchConnectInfo(): Promise<number>;
    /**
     * Get the gateway endpoint to connect to.
     * @returns String url with the Gateway Endpoint to connect to.
     */
    getGateway(): Promise<string>;
    /**
     * Get the GatewayData including recommended amount of shards and other helpful info.
     * @returns Object with url and shards to use to connect to discord.
     */
    getGatewayBot(): Promise<APIGatewayBotInfo>;
    /**
     * Disconnect the bot gracefully,
     * you will receive a 'disconnected' event once the ShardManager successfully closes all shard websocket connections.
     */
    disconnect(): void;
    /**
     * Send an OP 3 PRESENCE_UPDATE to Discord, which updates the status of all shards facilitated by this client's ShardManager.
     * @returns Promise that's resolved once all shards have sent the websocket payload.
     *
     * @example
     * // Connect to Discord and set status to do not disturb and activity to "Memes are Dreams".
     * const CloudStorm = require("cloudstorm"); // CloudStorm also supports import statements.
     * const token = "token";
     * const client = new CloudStorm.Client(token);
     * client.connect();
     * client.once("ready", () => {
     * 	// Client is connected to Discord and is ready, so we can update the status.
     * 	client.presenceUpdate({ status: "dnd", activities: [{ name: "Memes are Dreams", type: 0 }] });
     * });
     */
    presenceUpdate(data: Parameters<Client["shardManager"]["presenceUpdate"]>["0"]): Promise<void>;
    /**
     * Send an OP 3 PRESENCE_UPDATE to Discord, which updates the status of a single shard facilitated by this client's ShardManager.
     * @param shardId id of the shard that should update it's status.
     * @param data Presence data to send.
     * @returns Promise that's resolved once the shard has sent the websocket payload.
     *
     * @example
     * // Connect to Discord and set status to do not disturb and activity to "Im shard 0".
     * const CloudStorm = require("cloudstorm"); // CloudStorm also supports import statements.
     * const token = "token";
     * const client = new CloudStorm.Client(token);
     * client.connect();
     * client.once("ready", () => {
     * 	// Client is connected to Discord and is ready, so we can update the status of shard 0.
     * 	client.shardPresenceUpdate(0, { status: "dnd", activities: [{ name: "Im shard 0", type: 0 }] });
     * });
     */
    shardStatusUpdate(shardId: number, data: Parameters<Client["shardManager"]["shardPresenceUpdate"]>["1"]): Promise<void>;
    /**
     * Send an OP 4 VOICE_STATE_UPDATE to Discord. this does **not** allow you to send audio with CloudStorm itself,
     * it just provides the necessary data for another application to send audio data to Discord.
     * @param shardId id of the shard that should send the payload.
     * @param data Voice state update data to send.
     * @returns Promise that's resolved once the payload was sent to Discord.
     *
     * @example
     * // Connect to Discord and join a voice channel
     * const CloudStorm = require("cloudstorm"); // CloudStorm also supports import statements.
     * const token = "token";
     * const client = new CloudStorm.Client(token);
     * client.connect();
     * client.once("ready", () => {
     * 	// Client is connected to Discord and is ready, so we can join a voice channel.
     * 	// We will use shard 0 as the shard to send the payload.
     * 	client.voiceStateUpdate(0, { guild_id: "id", channel_id: "id", self_mute: false, self_deaf: false });
     * });
     */
    voiceStateUpdate(shardId: number, data: Parameters<Client["shardManager"]["voiceStateUpdate"]>["1"]): Promise<void>;
    /**
     * Send an OP 8 REQUEST_GUILD_MEMBERS to Discord.
     * @param shardId id of the shard that should send the payload.
     * @param data Request guild members data to send.
     * @returns Promise that's resolved once the payload was send to Discord.
     *
     * @example
     * // Connect to Discord and request guild members.
     * const CloudStorm = require("cloudstorm"); // CloudStorm also supports import statements.
     * const token = "token";
     * const client = new CloudStorm.Client(token);
     * client.connect();
     * client.once("ready", () => {
     * 	// Client is connected to Discord and is ready, so we can send the request guild members payload.
     * 	// We will use shard 0 as the shard to send the payload.
     * 	client.requestGuildMembers(0, { guild_id: "id" });
     * });
     */
    requestGuildMembers(shardId: number, data: Parameters<Client["shardManager"]["requestGuildMembers"]>["1"]): Promise<void>;
    /**
     * Update the endpoint shard websockets will connect to.
     * @param gatewayUrl Base gateway wss url to update the cached endpoint to.
     */
    private _updateEndpoint;
}

declare const Constants: {
    GATEWAY_OP_CODES: {
        /**
         * Receive.
         */
        DISPATCH: 0;
        /**
         * Send/Receive.
         */
        HEARTBEAT: 1;
        /**
         * Send.
         */
        IDENTIFY: 2;
        /**
         * Send.
         */
        PRESENCE_UPDATE: 3;
        /**
         * Send.
         */
        VOICE_STATE_UPDATE: 4;
        /**
         * Send.
         */
        RESUME: 6;
        /**
         * Receive.
         */
        RECONNECT: 7;
        /**
         * Send.
         */
        REQUEST_GUILD_MEMBERS: 8;
        /**
         * Receive.
         */
        INVALID_SESSION: 9;
        /**
         * Receive.
         */
        HELLO: 10;
        /**
         * Receive.
         */
        HEARTBEAT_ACK: 11;
    };
    GATEWAY_VERSION: 10;
};

export { BetterWs, Client, Constants, type IClientOptions, type IClientWSOptions, type IGatewayDispatch, type IGatewayMessage, _default as Intents, Shard, ShardManager };
