"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreadMetadata = exports.ThreadMember = void 0;
const baseset_1 = require("../collections/baseset");
const constants_1 = require("../constants");
const basestructure_1 = require("./basestructure");
const keysThreadMember = new baseset_1.BaseSet([
    constants_1.DiscordKeys.FLAGS,
    constants_1.DiscordKeys.ID,
    constants_1.DiscordKeys.JOIN_TIMESTAMP,
    constants_1.DiscordKeys.USER_ID,
]);
/**
 * Thread Member Structure
 * @category Structure
 */
class ThreadMember extends basestructure_1.BaseStructure {
    constructor(client, data, isClone) {
        super(client, undefined, isClone);
        this._keys = keysThreadMember;
        this.flags = 0;
        this.id = '';
        this.joinTimestampUnix = 0;
        this.userId = '';
        this.merge(data);
    }
    get joinTimestamp() {
        return new Date(this.joinTimestampUnix);
    }
    get thread() {
        if (this.client.channels.has(this.id)) {
            return this.client.channels.get(this.id);
        }
        return null;
    }
    get user() {
        return this.client.users.get(this.userId) || null;
    }
    add() {
        return this.client.rest.addThreadMember(this.id, this.userId);
    }
    remove() {
        return this.client.rest.removeThreadMember(this.id, this.userId);
    }
    mergeValue(key, value) {
        if (value !== undefined) {
            switch (key) {
                case constants_1.DiscordKeys.JOIN_TIMESTAMP:
                    {
                        this.joinTimestampUnix = (new Date(value)).getTime();
                    }
                    ;
                    return;
            }
            return super.mergeValue(key, value);
        }
    }
}
exports.ThreadMember = ThreadMember;
const keysThreadMetadata = new baseset_1.BaseSet([
    constants_1.DiscordKeys.ARCHIVE_TIMESTAMP,
    constants_1.DiscordKeys.ARCHIVED,
    constants_1.DiscordKeys.ARCHIVER_ID,
    constants_1.DiscordKeys.AUTO_ARCHIVE_DURATION,
    constants_1.DiscordKeys.LOCKED,
]);
/**
 * Thread Metadata Structure
 * @category Structure
 */
class ThreadMetadata extends basestructure_1.BaseStructure {
    constructor(channel, data, isClone) {
        super(channel.client, undefined, isClone);
        this._keys = keysThreadMetadata;
        this.archiveTimestampUnix = 0;
        this.archived = false;
        this.autoArchiveDuration = 60;
        this.channel = channel;
        this.merge(data);
    }
    get archiver() {
        if (this.archiverId) {
            return this.client.users.get(this.archiverId) || null;
        }
        return null;
    }
    get archiveTimestamp() {
        return new Date(this.archiveTimestampUnix);
    }
    mergeValue(key, value) {
        if (value !== undefined) {
            switch (key) {
                case constants_1.DiscordKeys.ARCHIVE_TIMESTAMP:
                    {
                        this.archiveTimestampUnix = (new Date(value)).getTime();
                    }
                    ;
                    return;
            }
            return super.mergeValue(key, value);
        }
    }
}
exports.ThreadMetadata = ThreadMetadata;
