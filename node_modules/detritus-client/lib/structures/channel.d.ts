import { RequestTypes } from 'detritus-client-rest';
import { ShardClient, VoiceConnectObject, VoiceConnectOptions } from '../client';
import { BaseCollection } from '../collections/basecollection';
import { BaseSet } from '../collections/baseset';
import { ChannelTypes, ChannelVideoQualityModes } from '../constants';
import { PartialBy, PermissionTools, UrlQuery } from '../utils';
import { BaseStructure, BaseStructureData } from './basestructure';
import { Guild } from './guild';
import { Member } from './member';
import { Message } from './message';
import { Overwrite } from './overwrite';
import { Role } from './role';
import { StageInstance } from './stageinstance';
import { ThreadMember, ThreadMetadata } from './thread';
import { Typing } from './typing';
import { User } from './user';
import { VoiceState } from './voicestate';
export declare type Channel = (ChannelBase | ChannelDM | ChannelGuildVoice | ChannelDMGroup | ChannelGuildType);
export declare type ChannelGuildType = (ChannelGuildBase | ChannelGuildCategory | ChannelGuildText | ChannelGuildStore | ChannelGuildThread | ChannelGuildStageVoice);
export declare type ChannelTextType = (ChannelDM | ChannelDMGroup | ChannelGuildText | ChannelGuildThread);
export declare function createChannelFromData(client: ShardClient, data?: BaseStructureData, isClone?: boolean): Channel;
/**
 * Basic Channel Structure
 * @category Structure
 */
export declare class ChannelBase extends BaseStructure {
    readonly _keys: BaseSet<string>;
    readonly _keysMerge: BaseSet<string>;
    _name: string;
    _nicks?: BaseCollection<string, string>;
    _nsfw?: boolean;
    _permissionOverwrites?: BaseCollection<string, Overwrite>;
    _recipients?: BaseCollection<string, User>;
    applicationId?: string;
    bitrate?: number;
    deleted: boolean;
    guildId?: string;
    id: string;
    icon?: null | string;
    isPartial: boolean;
    lastMessageId?: null | string;
    lastPinTimestampUnix?: number;
    member?: ThreadMember;
    memberCount?: number;
    messageCount?: number;
    ownerId?: string;
    parentId?: null | string;
    position?: number;
    rateLimitPerUser?: number;
    rtcRegion?: null | string;
    threadMetadata?: ThreadMetadata;
    topic: null | string;
    type: ChannelTypes;
    userLimit?: number;
    videoQualityMode?: ChannelVideoQualityModes;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get canAddReactions(): boolean;
    get canAttachFiles(): boolean;
    get canDeafenMembers(): boolean;
    get canEdit(): boolean;
    get canEmbedLinks(): boolean;
    get canJoin(): boolean;
    get canManageMessages(): boolean;
    get canManageWebhooks(): boolean;
    get canMentionEveryone(): boolean;
    get canMessage(): boolean;
    get canManageThreads(): boolean;
    get canMoveMembers(): boolean;
    get canMuteMembers(): boolean;
    get canPrioritySpeaker(): boolean;
    get canSendTTSMessage(): boolean;
    get canSpeak(): boolean;
    get canStream(): boolean;
    get canReadHistory(): boolean;
    get canUseExternalEmojis(): boolean;
    get canUsePrivateThreads(): boolean;
    get canUsePublicThreads(): boolean;
    get canUseVAD(): boolean;
    get canView(): boolean;
    get children(): BaseCollection<string, ChannelGuildType>;
    get createdAt(): Date;
    get createdAtUnix(): number;
    get defaultIconUrl(): null | string;
    get guild(): Guild | null;
    get iconUrl(): null | string;
    get isDm(): boolean;
    get isDmGroup(): boolean;
    get isDmSingle(): boolean;
    get isGuildCategory(): boolean;
    get isGuildChannel(): boolean;
    get isGuildNews(): boolean;
    get isGuildStageVoice(): boolean;
    get isGuildStore(): boolean;
    get isGuildText(): boolean;
    get isGuildThread(): boolean;
    get isGuildThreadNews(): boolean;
    get isGuildThreadPrivate(): boolean;
    get isGuildThreadPublic(): boolean;
    get isGuildVoice(): boolean;
    get isLive(): boolean;
    get isManaged(): boolean;
    get isSyncedWithParent(): boolean;
    get isText(): boolean;
    get isVoice(): boolean;
    get joined(): boolean;
    get jumpLink(): string;
    get lastMessage(): Message | null;
    get lastPinTimestamp(): Date | null;
    get members(): BaseCollection<string, Member>;
    get messages(): BaseCollection<string, Message>;
    get mention(): string;
    get name(): string;
    get nicks(): BaseCollection<string, string>;
    get nsfw(): boolean;
    get owner(): User | null;
    get parent(): ChannelGuildCategory | ChannelGuildText | null;
    get permissionOverwrites(): BaseCollection<string, Overwrite>;
    get stageInstance(): StageInstance | null;
    get recipients(): BaseCollection<string, User>;
    get typing(): BaseCollection<string, Typing>;
    get voiceStates(): BaseCollection<string, VoiceState>;
    can(permissions: PermissionTools.PermissionChecks, memberOrRole?: Member | Role): boolean;
    iconUrlFormat(format?: null | string, query?: UrlQuery): null | string;
    isSyncedWith(parent: ChannelGuildCategory | null): boolean;
    addPinnedMessage(messageId: string): Promise<any>;
    addMember(userId: string): Promise<any>;
    addRecipient(userId: string): Promise<any>;
    bulkDelete(messageIds: Array<string>): Promise<any>;
    close(): Promise<Channel>;
    createInvite(options: RequestTypes.CreateChannelInvite): Promise<import("./invite").Invite>;
    createMessage(options?: RequestTypes.CreateMessage | string): Promise<Message>;
    createReaction(messageId: string, emoji: string): Promise<any>;
    createStageInstance(options: PartialBy<RequestTypes.CreateStageInstance, 'channelId'>): Promise<StageInstance>;
    createThread(options: RequestTypes.CreateChannelThread): Promise<ChannelGuildThread>;
    createWebhook(options: RequestTypes.CreateWebhook): Promise<import("./webhook").Webhook>;
    crosspostMessage(messageId: string): Promise<Message>;
    delete(options?: RequestTypes.DeleteChannel): Promise<Channel>;
    deleteMessage(messageId: string, options?: RequestTypes.DeleteMessage): Promise<any>;
    deleteOverwrite(overwriteId: string, options?: RequestTypes.DeleteChannelOverwrite): Promise<any>;
    deletePin(messageId: string): Promise<any>;
    deleteReaction(messageId: string, emoji: string, userId?: string): Promise<any>;
    deleteReactions(messageId: string): Promise<any>;
    deleteStageInstance(): Promise<any>;
    edit(options?: RequestTypes.EditChannel): Promise<Channel>;
    editMessage(messageId: string, options?: RequestTypes.EditMessage): Promise<Message>;
    editOverwrite(overwriteId: string, options?: RequestTypes.EditChannelOverwrite): Promise<any>;
    editStageInstance(options?: RequestTypes.EditStageInstance): Promise<any>;
    fetchCallStatus(): Promise<any>;
    fetchInvites(): Promise<BaseCollection<string, import("./invite").Invite>>;
    fetchMembers(): Promise<BaseCollection<string, ThreadMember>>;
    fetchMessage(messageId: string): Promise<Message>;
    fetchMessages(options?: RequestTypes.FetchMessages): Promise<BaseCollection<string, Message>>;
    fetchPins(): Promise<BaseCollection<string, Message>>;
    fetchReactions(messageId: string, emoji: string, options?: RequestTypes.FetchReactions): Promise<BaseCollection<string, User>>;
    fetchStageInstance(): Promise<StageInstance>;
    fetchStoreListing(): Promise<import("./store").StoreListing>;
    fetchThreadsActive(): Promise<import("../rest/types").RestResponses.FetchChannelThreadsActive>;
    fetchThreadsArchivedPrivate(options?: RequestTypes.FetchChannelThreadsArchivedPrivate): Promise<import("../rest/types").RestResponses.FetchChannelThreadsArchivedPrivate>;
    fetchThreadsArchivedPrivateJoined(options?: RequestTypes.FetchChannelThreadsArchivedPrivateJoined): Promise<import("../rest/types").RestResponses.FetchChannelThreadsArchivedPrivateJoined>;
    fetchThreadsArchivedPublic(options?: RequestTypes.FetchChannelThreadsArchivedPublic): Promise<import("../rest/types").RestResponses.FetchChannelThreadsArchivedPublic>;
    fetchWebhooks(): Promise<BaseCollection<string, import("./webhook").Webhook>>;
    follow(options: RequestTypes.FollowChannel): Promise<{
        channelId: string;
        webhookId: string;
    }>;
    grantEntitlement(): Promise<void>;
    join(): Promise<void>;
    join(options?: CallOptions): Promise<VoiceConnectObject | null>;
    leave(): Promise<any>;
    removeMember(userId: string): Promise<any>;
    removeRecipient(userId: string): Promise<any>;
    search(options: RequestTypes.SearchOptions, retry?: boolean): Promise<any>;
    startCallRinging(recipients?: Array<string>): Promise<any>;
    stopCallRinging(recipients?: Array<string>): Promise<any>;
    triggerTyping(): Promise<any>;
    turnIntoNewsChannel(): Promise<Channel>;
    turnIntoTextChannel(): Promise<Channel>;
    unack(): Promise<any>;
    mergeValue(key: string, value: any): void;
    toString(): string;
}
export interface CallOptions extends VoiceConnectOptions {
    recipients?: Array<string>;
    verify?: boolean;
}
/**
 * Single DM Channel
 * @category Structure
 */
export declare class ChannelDM extends ChannelBase {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    lastMessageId?: null | string;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get iconUrl(): null | string;
    get joined(): boolean;
    get messages(): BaseCollection<string, Message>;
    get name(): string;
    get voiceStates(): BaseCollection<string, VoiceState>;
    iconUrlFormat(format?: null | string, query?: UrlQuery): null | string;
    mergeValue(key: string, value: any): void;
}
/**
 * Group DM Channel
 * @category Structure
 */
export declare class ChannelDMGroup extends ChannelDM {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    applicationId?: string;
    icon: null | string;
    ownerId: string;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get defaultIconUrl(): string;
    get owner(): User | null;
    iconUrlFormat(format?: null | string, query?: UrlQuery): string;
    isOwner(userId: string): boolean;
}
/**
 * Basic Guild Channel
 * @category Structure
 */
export declare class ChannelGuildBase extends ChannelBase {
    readonly _keys: BaseSet<string>;
    readonly _keysMerge: BaseSet<string>;
    type: ChannelTypes;
    guildId: string;
    parentId: null | string;
    position: number;
    rateLimitPerUser: number;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get canAddReactions(): boolean;
    get canAttachFiles(): boolean;
    get canDeafenMembers(): boolean;
    get canEdit(): boolean;
    get canEmbedLinks(): boolean;
    get canJoin(): boolean;
    get canManageMessages(): boolean;
    get canManageWebhooks(): boolean;
    get canManageThreads(): boolean;
    get canMentionEveryone(): boolean;
    get canMessage(): boolean;
    get canMoveMembers(): boolean;
    get canMuteMembers(): boolean;
    get canPrioritySpeaker(): boolean;
    get canSendTTSMessage(): boolean;
    get canSpeak(): boolean;
    get canStream(): boolean;
    get canReadHistory(): boolean;
    get canUseExternalEmojis(): boolean;
    get canUsePrivateThreads(): boolean;
    get canUsePublicThreads(): boolean;
    get canUseVAD(): boolean;
    get canView(): boolean;
    get guild(): Guild | null;
    get jumpLink(): string;
    can(permissions: PermissionTools.PermissionChecks, memberOrRole?: Member | Role, { ignoreAdministrator, ignoreOwner }?: {
        ignoreAdministrator?: boolean;
        ignoreOwner?: boolean;
    }): boolean;
    isSyncedWith(parent: ChannelGuildCategory | null): boolean;
    mergeValue(key: string, value: any): void;
}
/**
 * Guild Category Channel
 * @category Structure
 */
export declare class ChannelGuildCategory extends ChannelGuildBase {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get children(): BaseCollection<string, ChannelGuildType>;
}
/**
 * Guild Text Channel, it can also be a news channel.
 * @category Structure
 */
export declare class ChannelGuildText extends ChannelGuildBase {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    lastMessageId: null | string;
    topic: null | string;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get members(): BaseCollection<string, Member>;
    get messages(): BaseCollection<string, Message>;
    mergeValue(key: string, value: any): void;
}
/**
 * Guild Voice Channel
 * @category Structure
 */
export declare class ChannelGuildVoice extends ChannelGuildBase {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    bitrate: number;
    rtcRegion: string | null;
    userLimit: number;
    videoQualityMode: ChannelVideoQualityModes;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get joined(): boolean;
    get members(): BaseCollection<string, Member>;
    get voiceStates(): BaseCollection<string, VoiceState>;
}
/**
 * Guild Store Channel
 * @category Structure
 */
export declare class ChannelGuildStore extends ChannelGuildBase {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    bitrate: number;
    userLimit: number;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
}
/**
 * Guild Stage Voice Channel
 * @category Structure
 */
export declare class ChannelGuildStageVoice extends ChannelGuildVoice {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    topic: null | string;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
}
/**
 * Guild Thread Channel
 * @category Structure
 */
export declare class ChannelGuildThread extends ChannelGuildBase {
    readonly _keys: BaseSet<string>;
    type: ChannelTypes;
    member?: ThreadMember;
    memberCount: number;
    messageCount: number;
    ownerId: string;
    threadMetadata: ThreadMetadata;
    constructor(client: ShardClient, data?: BaseStructureData, isClone?: boolean);
    get nsfw(): boolean;
    mergeValue(key: string, value: any): void;
}
