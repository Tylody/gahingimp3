import { EventEmitter } from 'events';
import { Response, FormData, File } from 'undici';
import { RESTGetAPIAuditLogQuery, RESTGetAPIAuditLogResult, RESTGetAPIAutoModerationRulesResult, RESTGetAPIAutoModerationRuleResult, RESTPostAPIAutoModerationRuleJSONBody, RESTPostAPIAutoModerationRuleResult, RESTPatchAPIAutoModerationRuleJSONBody, RESTPatchAPIAutoModerationRuleResult, RESTDeleteAPIAutoModerationRuleResult, RESTGetAPIGatewayResult, RESTGetAPIGatewayBotResult, RESTGetAPIChannelResult, RESTPatchAPIChannelJSONBody, RESTPatchAPIChannelResult, APIThreadChannel, RESTDeleteAPIChannelResult, RESTGetAPIChannelMessagesQuery, RESTGetAPIChannelMessagesResult, RESTGetAPIChannelMessageResult, RESTPostAPIChannelMessageJSONBody, RESTPostAPIChannelMessageResult, RESTPostAPIChannelMessageCrosspostResult, RESTPutAPIChannelMessageReactionResult, RESTDeleteAPIChannelMessageUserReactionResult, RESTDeleteAPIChannelMessageReactionResult, RESTGetAPIChannelMessageReactionUsersQuery, RESTGetAPIChannelMessageReactionUsersResult, RESTDeleteAPIChannelAllMessageReactionsResult, RESTPatchAPIChannelMessageJSONBody, RESTPatchAPIChannelMessageResult, RESTDeleteAPIChannelMessageResult, RESTPostAPIChannelMessagesBulkDeleteResult, RESTPutAPIChannelPermissionJSONBody, RESTPutAPIChannelPermissionResult, RESTGetAPIChannelInvitesResult, RESTPostAPIChannelInviteJSONBody, RESTPostAPIChannelInviteResult, RESTDeleteAPIChannelPermissionResult, RESTPostAPIChannelFollowersResult, RESTPostAPIChannelTypingResult, RESTGetAPIChannelPinsResult, RESTPutAPIChannelPinResult, RESTDeleteAPIChannelPinResult, RESTPostAPIChannelMessagesThreadsJSONBody, RESTPostAPIChannelMessagesThreadsResult, RESTPostAPIChannelThreadsJSONBody, APITextBasedChannel, ChannelType, RESTPutAPIChannelThreadMembersResult, RESTDeleteAPIChannelThreadMembersResult, RESTGetAPIChannelThreadMemberResult, RESTGetAPIChannelThreadMembersQuery, RESTGetAPIChannelThreadMembersResult, RESTGetAPIChannelThreadsArchivedQuery, RESTGetAPIChannelThreadsArchivedPublicResult, RESTGetAPIChannelThreadsArchivedPrivateResult, RESTGetAPIChannelUsersThreadsArchivedResult, RESTGetAPIGuildEmojisResult, RESTGetAPIGuildEmojiResult, RESTPostAPIGuildEmojiJSONBody, RESTPostAPIGuildEmojiResult, RESTPatchAPIGuildEmojiJSONBody, RESTPatchAPIGuildEmojiResult, RESTDeleteAPIGuildEmojiResult, RESTGetAPIStickerResult, RESTGetAPIGuildStickersResult, RESTGetAPIGuildStickerResult, RESTPostAPIGuildStickerFormDataBody, RESTPostAPIGuildStickerResult, RESTPatchAPIGuildStickerJSONBody, RESTPatchAPIGuildStickerResult, RESTDeleteAPIGuildStickerResult, RESTPostAPIGuildsJSONBody, RESTPostAPIGuildsResult, RESTGetAPIGuildResult, RESTGetAPIGuildPreviewResult, RESTPatchAPIGuildJSONBody, RESTPatchAPIGuildResult, RESTDeleteAPIGuildResult, RESTGetAPIGuildChannelsResult, RESTPostAPIGuildChannelJSONBody, RESTPostAPIGuildChannelResult, RESTPatchAPIGuildChannelPositionsJSONBody, RESTPatchAPIGuildChannelPositionsResult, RESTGetAPIGuildThreadsResult, RESTGetAPIGuildMemberResult, RESTGetAPIGuildMembersQuery, RESTGetAPIGuildMembersResult, RESTGetAPIGuildMembersSearchQuery, RESTGetAPIGuildMembersSearchResult, RESTPutAPIGuildMemberJSONBody, RESTPutAPIGuildMemberResult, RESTPatchAPIGuildMemberJSONBody, RESTPatchAPIGuildMemberResult, RESTPatchAPICurrentGuildMemberJSONBody, APIGuildMember, RESTPutAPIGuildMemberRoleResult, RESTDeleteAPIGuildMemberRoleResult, RESTDeleteAPIGuildMemberResult, RESTGetAPIGuildBansQuery, RESTGetAPIGuildBansResult, RESTGetAPIGuildBanResult, RESTPutAPIGuildBanJSONBody, RESTPutAPIGuildBanResult, RESTDeleteAPIGuildBanResult, RESTGetAPIGuildRolesResult, RESTPostAPIGuildRoleJSONBody, RESTPostAPIGuildRoleResult, RESTPatchAPIGuildRolePositionsJSONBody, RESTPatchAPIGuildRolePositionsResult, RESTPatchAPIGuildRoleJSONBody, RESTPatchAPIGuildRoleResult, RESTDeleteAPIGuildRoleResult, RESTGetAPIGuildPruneCountQuery, RESTGetAPIGuildPruneCountResult, RESTPostAPIGuildPruneJSONBody, RESTPostAPIGuildPruneResult, RESTGetAPIGuildVoiceRegionsResult, RESTGetAPIGuildInvitesResult, RESTGetAPIGuildIntegrationsResult, RESTDeleteAPIGuildIntegrationResult, RESTGetAPIGuildWidgetSettingsResult, RESTPatchAPIGuildWidgetSettingsJSONBody, RESTPatchAPIGuildWidgetSettingsResult, APIGuildWidget, RESTGetAPIGuildVanityUrlResult, RESTGetAPIGuildWelcomeScreenResult, RESTPatchAPIGuildWelcomeScreenJSONBody, RESTPatchAPIGuildWelcomeScreenResult, RESTPatchAPIGuildVoiceStateCurrentMemberJSONBody, RESTPatchAPIGuildVoiceStateCurrentMemberResult, RESTPatchAPIGuildVoiceStateUserJSONBody, RESTPatchAPIGuildVoiceStateUserResult, RESTGetAPIGuildScheduledEventsResult, RESTPostAPIGuildScheduledEventJSONBody, RESTPostAPIGuildScheduledEventResult, RESTGetAPIGuildScheduledEventResult, RESTPatchAPIGuildScheduledEventJSONBody, RESTPatchAPIGuildScheduledEventResult, RESTDeleteAPIGuildScheduledEventResult, RESTGetAPIGuildScheduledEventUsersQuery, RESTGetAPIGuildScheduledEventUsersResult, RESTGetAPITemplateResult, RESTPostAPITemplateCreateGuildJSONBody, RESTPostAPITemplateCreateGuildResult, RESTGetAPIGuildTemplatesResult, RESTPostAPIGuildTemplatesJSONBody, RESTPostAPIGuildTemplatesResult, RESTPutAPIGuildTemplateSyncResult, RESTPatchAPIGuildTemplateJSONBody, RESTPatchAPIGuildTemplateResult, RESTDeleteAPIGuildTemplateResult, RESTPostAPIChannelWebhookJSONBody, RESTPostAPIChannelWebhookResult, RESTGetAPIChannelWebhooksResult, RESTGetAPIGuildWebhooksResult, RESTGetAPIWebhookResult, RESTPatchAPIWebhookWithTokenJSONBody, RESTPatchAPIWebhookWithTokenResult, RESTPatchAPIWebhookJSONBody, RESTPatchAPIWebhookResult, RESTDeleteAPIWebhookResult, RESTPostAPIWebhookWithTokenJSONBody, RESTPostAPIWebhookWithTokenQuery, RESTPostAPIWebhookWithTokenResult, RESTPostAPIWebhookWithTokenWaitResult, RESTPostAPIWebhookWithTokenSlackQuery, RESTPostAPIWebhookWithTokenSlackResult, RESTPostAPIWebhookWithTokenSlackWaitResult, RESTPostAPIWebhookWithTokenGitHubQuery, RESTPostAPIWebhookWithTokenGitHubResult, RESTPostAPIWebhookWithTokenGitHubWaitResult, RESTGetAPIWebhookWithTokenMessageResult, RESTPatchAPIWebhookWithTokenMessageJSONBody, RESTPatchAPIWebhookWithTokenMessageResult, RESTDeleteAPIWebhookWithTokenMessageResult, RESTGetAPIApplicationCommandsResult, RESTPostAPIApplicationCommandsJSONBody, RESTPostAPIApplicationCommandsResult, RESTGetAPIApplicationCommandResult, RESTPatchAPIApplicationCommandJSONBody, RESTPatchAPIApplicationCommandResult, RESTPutAPIApplicationCommandsJSONBody, RESTPutAPIApplicationCommandsResult, RESTGetAPIApplicationGuildCommandsResult, RESTPostAPIApplicationGuildCommandsJSONBody, RESTPostAPIApplicationGuildCommandsResult, RESTGetAPIApplicationGuildCommandResult, RESTPatchAPIApplicationGuildCommandJSONBody, RESTPatchAPIApplicationGuildCommandResult, RESTPutAPIApplicationGuildCommandsJSONBody, RESTPutAPIApplicationGuildCommandsResult, RESTGetAPIApplicationCommandPermissionsResult, RESTPutAPIApplicationCommandPermissionsJSONBody, RESTPutAPIApplicationCommandPermissionsResult, RESTPostAPIInteractionCallbackJSONBody, RESTGetAPIInteractionOriginalResponseResult, RESTPatchAPIInteractionOriginalResponseJSONBody, RESTPatchAPIInteractionOriginalResponseResult, RESTDeleteAPIInteractionOriginalResponseResult, RESTPostAPIInteractionFollowupJSONBody, RESTPostAPIInteractionFollowupResult, RESTGetAPIInteractionFollowupResult, RESTPatchAPIInteractionFollowupJSONBody, RESTPatchAPIInteractionFollowupResult, RESTDeleteAPIInteractionFollowupResult, RESTGetAPIInviteQuery, RESTGetAPIInviteResult, RESTDeleteAPIInviteResult, RESTPostAPIStageInstanceJSONBody, RESTPostAPIStageInstanceResult, RESTGetAPIStageInstanceResult, RESTPatchAPIStageInstanceJSONBody, RESTPatchAPIStageInstanceResult, RESTDeleteAPIStageInstanceResult, RESTGetAPICurrentUserResult, RESTGetAPIUserResult, RESTPatchAPICurrentUserJSONBody, RESTPatchAPICurrentUserResult, RESTGetAPICurrentUserGuildsQuery, RESTGetAPICurrentUserGuildsResult, RESTDeleteAPICurrentUserGuildResult, RESTPostAPICurrentUserCreateDMChannelResult, RESTGetAPICurrentUserConnectionsResult, RESTGetAPICurrentUserApplicationRoleConnectionResult, RESTPutAPICurrentUserApplicationRoleConnectionJSONBody, RESTPutAPICurrentUserApplicationRoleConnectionResult, RESTGetAPIVoiceRegionsResult } from 'discord-api-types/v10';
import { Readable } from 'stream';
import { ReadableStream } from 'stream/web';
import { Blob } from 'buffer';

type HTTPMethod = "get" | "post" | "patch" | "head" | "put" | "delete" | "connect" | "options" | "trace";
declare class DiscordAPIError extends Error {
    path: string;
    method: HTTPMethod;
    code: number;
    httpStatus: number;
    constructor(path: string, error: {
        message?: string;
        code?: number;
    }, method: HTTPMethod, status: number);
}
/**
 * Ratelimiter used for handling the ratelimits imposed by the rest api
 * @protected
 */
declare class Ratelimiter<B extends typeof GlobalBucket = typeof GlobalBucket> {
    /**
     * An object of Buckets that store rate limit info
     */
    buckets: {
        [routeKey: string]: InstanceType<B>;
    };
    /**
     * If you're being globally rate limited
     */
    private _global;
    /**
     * Timeframe in milliseconds until when the global rate limit resets
     */
    globalReset: number;
    /**
     * Timeout that resets the global ratelimit once the timeframe has passed
     */
    globalResetTimeout: NodeJS.Timeout | null;
    /**
     * The constructor function to call new on when creating buckets to cache and use
     */
    BucketConstructor: B;
    /**
     * If you're being globally rate limited
     */
    get global(): boolean;
    /**
     * If you're being globally rate limited
     */
    set global(value: boolean);
    /**
     * Returns a key for saving ratelimits for routes
     * (Taken from https://github.com/abalabahaha/eris/blob/master/lib/rest/RequestHandler.js) -> I luv u abal <3
     * @param url url to reduce to a key something like /channels/266277541646434305/messages/266277541646434305/
     * @param method method of the request, usual http methods like get, etc.
     * @returns reduced url: /channels/266277541646434305/messages/:id/
     */
    routify(url: string, method: string): string;
    /**
     * Queue a rest call to be executed
     * @param fn function to call once the ratelimit is ready
     * @param url Endpoint of the request
     * @param method Http method used by the request
     */
    queue(fn: (bucket: InstanceType<B>) => any, url: string, method: string): void;
}
/**
 * Bucket used for saving ratelimits
 * @protected
 */
declare class LocalBucket {
    limit: number;
    reset: number;
    /**
     * Remaining amount of executions during the current timeframe
     */
    remaining: number;
    /**
     * array of functions waiting to be executed
     */
    fnQueue: Array<() => any>;
    /**
     * Timeout that calls the reset function once the timeframe passed
     */
    resetTimeout: NodeJS.Timeout | null;
    /**
     * Create a new base bucket
     * @param limit Number of functions that may be executed during the timeframe set in reset
     * @param reset Timeframe in milliseconds until the ratelimit resets after first
     * @param remaining Remaining amount of executions during the current timeframe
     */
    constructor(limit?: number, reset?: number, remaining?: number);
    /**
     * Queue a function to be executed
     * @param fn function to be executed
     * @returns Result of the function if any
     */
    queue<T>(fn: (bucket: this) => T): Promise<T>;
    makeResetTimeout(durationMS: number): void;
    /**
     * Check if there are any functions in the queue that haven't been executed yet
     */
    checkQueue(): void;
    /**
     * Reset the remaining tokens to the base limit
     */
    resetRemaining(): void;
    /**
     * Clear the current queue of events to be sent
     */
    dropQueue(): void;
}
/**
 * Extended bucket that respects global ratelimits
 * @protected
 */
declare class GlobalBucket extends LocalBucket {
    ratelimiter: Ratelimiter;
    routeKey: string;
    /**
     * Create a new bucket that respects global rate limits
     * @param ratelimiter ratelimiter used for ratelimiting requests. Assigned by ratelimiter
     * @param routeKey Key used internally to routify requests. Assigned by ratelimiter
     */
    constructor(ratelimiter: Ratelimiter, routeKey: string);
    /**
     * Check if there are any functions in the queue that haven't been executed yet
     */
    checkQueue(): void;
    /**
     * Reset the remaining tokens to the base limit
     */
    resetRemaining(): void;
}
type HandlerEvents = {
    request: [string, {
        endpoint: string;
        method: HTTPMethod;
        dataType: "json" | "multipart";
        data: any;
    }];
    done: [string, Response];
    requestError: [string, Error];
    rateLimit: [{
        timeout: number;
        remaining: number;
        limit: number;
        method: HTTPMethod;
        path: string;
        route: string;
    }];
};
interface RequestHandler {
    addListener<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
    emit<E extends keyof HandlerEvents>(event: E, ...args: HandlerEvents[E]): boolean;
    eventNames(): Array<keyof HandlerEvents>;
    listenerCount(event: keyof HandlerEvents): number;
    listeners(event: keyof HandlerEvents): Array<(...args: Array<any>) => any>;
    off<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
    on<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
    once<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
    prependListener<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
    prependOnceListener<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
    rawListeners(event: keyof HandlerEvents): Array<(...args: Array<any>) => any>;
    removeAllListeners(event?: keyof HandlerEvents): this;
    removeListener<E extends keyof HandlerEvents>(event: E, listener: (...args: HandlerEvents[E]) => any): this;
}
/**
 * Request Handler class
 */
declare class RequestHandler extends EventEmitter {
    ratelimiter: Ratelimiter;
    options: {
        /** The base URL to use when making requests. Defaults to https://discord.com */
        baseHost: string;
        /** The base path of the base URL to use for the API. Defaults to /api/v${Constants.REST_API_VERSION} */
        baseURL: string;
        /** If rate limit buckets should be ignored */
        bypassBuckets: boolean;
        /** If failed requests that can be retried should be retried, up to retryLimit times. */
        retryFailed: boolean;
        /** How many times requests should be retried if they fail and can be retried. */
        retryLimit: number;
        headers: {
            Authorization?: string;
            "User-Agent": string;
        };
    };
    latency: number;
    apiURL: string;
    /**
     * Create a new request handler
     * @param ratelimiter ratelimiter to use for ratelimiting requests
     * @param options options
     */
    constructor(ratelimiter: Ratelimiter, options?: {
        token?: string;
    } & Partial<Omit<RequestHandler["options"], "headers">>);
    /**
     * Request a route from the discord api
     * @param endpoint endpoint to request
     * @param params URL query parameters to add on to the URL
     * @param method http method to use
     * @param dataType type of the data being sent
     * @param data data to send, if any
     * @returns Result of the request
     */
    request<T extends "json" | "multipart">(endpoint: string, params: Record<string, any> | undefined, method: HTTPMethod, dataType?: T, data?: T extends "json" ? any : FormData, extraHeaders?: Record<string, string>, retries?: number): Promise<any>;
    /**
     * Apply the received ratelimit headers to the ratelimit bucket
     * @param bkt Ratelimit bucket to apply the headers to
     * @param headers Http headers received from discord
     */
    private _applyRatelimitHeaders;
    /**
     * Execute a normal json request
     * @param endpoint Endpoint to use
     * @param params URL query parameters to add on to the URL
     * @param data Data to send
     * @returns Result of the request
     */
    private _request;
    /**
     * Execute a multipart/form-data request
     * @param endpoint Endpoint to use
     * @param params URL query parameters to add on to the URL
     * @param method Http Method to use
     * @param data data to send
     * @returns Result of the request
     */
    private _multiPartRequest;
}

/**
 * Methods for interacting with Guild Audit Logs
 */
declare class AuditLogMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Audit Log Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.auditLog.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get the audit logs of the specified guild id
     * @param guildId id of a guild
     * @param options optional audit log filter values
     * @returns An object with [audit log data](https://discord.com/developers/docs/resources/audit-log#audit-log-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | VIEW_AUDIT_LOG     | always    |
     *
     * @example
     * // Get an audit log entry of user 12345678901234567 updating themself (24 is MEMBER_UPDATE)
     * const client = new SnowTransfer("TOKEN")
     * const data = {
     * 	user_id: "12345678901234567",
     * 	action_type: 24,
     * }
     * const channel = await client.auditLog.getAuditLog("guild id", data)
     */
    getAuditLog(guildId: string, options?: RESTGetAPIAuditLogQuery): Promise<RESTGetAPIAuditLogResult>;
}

/**
 * Methods for interacting with guild auto moderation
 */
declare class AutoModerationMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Auto Moderation Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.autoMod.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get all of the auto moderation rules from a guild
     * @param guildId id of the guild
     * @returns A list of [auto mod rules](https://discord.com/developers/docs/resources/auto-moderation#auto-moderation-rule-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * // gets all automod rules of a guild
     * const client = new SnowTransfer("TOKEN")
     * const rules = await client.autoMod.getAutoModerationRules("guild id")
     */
    getAutoModerationRules(guildId: string): Promise<RESTGetAPIAutoModerationRulesResult>;
    /**
     * Get a auto moderation rules from a guild
     * @param guildId id of the guild
     * @param ruleId id of the rule
     * @returns An [auto mod rule](https://discord.com/developers/docs/resources/auto-moderation#auto-moderation-rule-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * // gets an automod rule from a guild
     * const client = new SnowTransfer("TOKEN")
     * const rule = await client.autoMod.getAutoModerationRule("guild id", "rule id")
     */
    getAutoModerationRule(guildId: string, ruleId: string): Promise<RESTGetAPIAutoModerationRuleResult>;
    /**
     * Create an auto moderation rule for a guild
     * @param guildId id of the guild
     * @param data the data of the auto moderation rule
     * @returns An [auto mod rule](https://discord.com/developers/docs/resources/auto-moderation#auto-moderation-rule-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const data = {
     * 	name: "mention_spam_prevent",
     * 	event_type: 1,
     * 	trigger_type: 5,
     * 	trigger_metadata: {
     * 		mention_total_limit: 6
     * 	},
     * 	actions: [
     * 		{
     * 			type: 1
     * 		}
     * 	]
     * }
     * const newRule = await client.autoMod.createAutoModerationRule("guild id", data)
     */
    createAutoModerationRule(guildId: string, data: RESTPostAPIAutoModerationRuleJSONBody & {
        reason?: string;
    }): Promise<RESTPostAPIAutoModerationRuleResult>;
    /**
     * Edit an auto moderation rule for a guild
     * @param guildId id of the guild
     * @param ruleId id of the rule
     * @param data the data of the auto moderation rule
     * @returns An [auto mod rule](https://discord.com/developers/docs/resources/auto-moderation#auto-moderation-rule-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * // Turn on the rule I forgot was disabled by default
     * const client = new SnowTransfer("TOKEN")
     * const data = {
     * 	name: "mention_spam_prevention",
     * 	enabled: true,
     * 	reason: "It's turned off by default and I forgor"
     * }
     * const updatedRule = await client.autoMod.editAutoModerationRule("guild id", "rule id", data)
     */
    editAutoModerationRule(guildId: string, ruleId: string, data: RESTPatchAPIAutoModerationRuleJSONBody & {
        reason?: string;
    }): Promise<RESTPatchAPIAutoModerationRuleResult>;
    /**
     * Deletes an auto moderation rule for a guild
     * @param guildId id of the guild
     * @param ruleId id of the rule
     * @param reason Reason for deleting the rule
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.autoMod.deleteAutoModerationRules("guild id", "rule id", "was useless")
     */
    deleteAutoModerationRule(guildId: string, ruleId: string, reason?: string): Promise<RESTDeleteAPIAutoModerationRuleResult>;
}

/**
 * Methods for interacting with bot specific endpoints
 */
declare class BotMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Bot Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.bot.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get the gateway url to connect to
     * @returns [Gateway data](https://discord.com/developers/docs/topics/gateway#get-gateway-example-response)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const result = await client.bot.getGateway()
     * // result should be something like { url: "wss://gateway.discord.gg" }
     */
    getGateway(): Promise<RESTGetAPIGatewayResult>;
    /**
     * Get the gateway url to connect to and a recommended amount of shards to use
     * @returns [Gateway data](https://discord.com/developers/docs/topics/gateway#get-gateway-example-response)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const result = await client.bot.getGatewayBot()
     * // result should be something like { url: "wss://gateway.discord.gg", shards: 1, session_start_limit: { total: 1000, remaining: 999, reset_after: 14400000, max_concurrency: 1 } }
     */
    getGatewayBot(): Promise<RESTGetAPIGatewayBotResult>;
}

/**
 * Methods for interacting with Channels and Messages
 */
declare class ChannelMethods {
    requestHandler: RequestHandler;
    disableEveryone: boolean;
    /**
     * Create a new Channel Method handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.channel.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     * @param disableEveryone Disable [at]everyone/[at]here on outgoing messages
     */
    constructor(requestHandler: RequestHandler, disableEveryone: boolean);
    /**
     * Get a channel via Id
     * @param channelId Id of the channel
     * @returns [discord channel](https://discord.com/developers/docs/resources/channel#channel-object) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const channel = await client.channel.getChannel("channel id")
     */
    getChannel(channelId: string): Promise<RESTGetAPIChannelResult>;
    /**
     * Update a guild channel or thread
     * @param channelId Id of the guild channel
     * @param data Data to send
     * @returns [discord channel](https://discord.com/developers/docs/resources/channel#channel-object) object
     *
     * | Permissions needed | Condition                                                                                                               |
     * |--------------------|-------------------------------------------------------------------------------------------------------------------------|
     * | MANAGE_CHANNELS    | always                                                                                                                  |
     * | MANAGE_ROLES       | If modifying permission overwrites                                                                                      |
     * | SEND_MESSAGES      | When editing a Thread to change the name, archived, auto_archive_duration, rate_limit_per_user or locked fields         |
     * | MANAGE_THREADS     | When editing a Thread and not modifying the name, archived, auto_archive_duration, rate_limit_per_user or locked fields |
     *
     * @example
     * // This example updates a channel with the passed id to use "New Name" as its name and "Look at this cool topic" as the topic
     * const client = new SnowTransfer("TOKEN")
     * const updateData = {
     * 	name: "New Name",
     * 	topic: "Look at this cool topic"
     * }
     * client.channel.updateChannel("channel id", updateData)
     */
    updateChannel(channelId: string, data: Omit<RESTPatchAPIChannelJSONBody, "archived" | "auto_archive_duration" | "locked" | "invitable"> & {
        reason?: string;
    }): Promise<Exclude<RESTPatchAPIChannelResult, APIThreadChannel>>;
    updateChannel(channelId: string, data: Pick<RESTPatchAPIChannelJSONBody, "archived" | "auto_archive_duration" | "locked" | "name" | "rate_limit_per_user"> & {
        reason?: string;
    }): Promise<Extract<RESTPatchAPIChannelResult, APIThreadChannel>>;
    /**
     * Delete a channel or thread via Id
     *
     * This either **deletes** a Guild Channel/thread or **closes** a Direct Message Channel
     *
     * **Be careful with deleting Guild Channels as this cannot be undone!**
     *
     * When deleting a category, this does **not** delete the child channels of a category. They will just have their `parent_id` removed.
     *
     * For community guilds, the rules channel and the community updates channel cannot be deleted.
     * @param channelId Id of the channel
     * @param reason Reason for deleting the channel
     * @returns [discord channel](https://discord.com/developers/docs/resources/channel#channel-object) object
     *
     * | Permissions needed | Condition                      |
     * |--------------------|--------------------------------|
     * | MANAGE_CHANNELS    | if channel is not a DM channel |
     * | MANAGE_THREADS     | if channel is a thread         |
     *
     * @example
     * // Deletes a channel via id because it wasn't needed anymore
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteChannel("channel id", "No longer needed")
     */
    deleteChannel(channelId: string, reason?: string): Promise<RESTDeleteAPIChannelResult>;
    /**
     * Get a list of messages from a channel
     * @param channelId Id of the channel
     * @param options Options for getting channel messages
     * @returns Array of [discord message](https://discord.com/developers/docs/resources/channel#message-object) objects
     *
     * | Permissions needed   | Condition                                                                        |
     * |----------------------|----------------------------------------------------------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel                                                   |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel, unless you want the API to return an empty Array |
     *
     * @example
     * // Fetch the last 20 messages from a channel
     * const client = new SnowTransfer("TOKEN")
     * const options = {
     * 	limit: 20
     * }
     * const messages = await client.channel.getChannelMessages("channel id", options)
     */
    getChannelMessages(channelId: string, options?: RESTGetAPIChannelMessagesQuery): Promise<RESTGetAPIChannelMessagesResult>;
    /**
     * Get a single message via Id
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @returns [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * | Permissions needed   | Condition                      |
     * |----------------------|--------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel |
     *
     * @example
     * // Get a single message from a channel via id
     * const client = new SnowTransfer("TOKEN")
     * const message = await client.channel.getChannelMessage("channel id", "message id")
     */
    getChannelMessage(channelId: string, messageId: string): Promise<RESTGetAPIChannelMessageResult>;
    /**
     * Creates a new Message within a channel or thread
     *
     * **Make sure to use a filename with a proper extension (e.g. png, jpeg, etc.) when you want to upload files**
     * @param channelId Id of the Channel or thread to send a message to
     * @param data Data to send, if data is a string it will be used as the content of the message,
     * if data is not a string you should take a look at the properties below to know what you may send
     * @param options Options for sending this message
     * @returns [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * | Permissions needed       | Condition                                                     |
     * |--------------------------|---------------------------------------------------------------|
     * | VIEW_CHANNEL             | if channel is not a DM channel                                |
     * | READ_MESSAGE_HISTORY     | if channel is not a DM channel and message is a reply         |
     * | SEND_MESSAGES            | if channel is not a DM channel and if channel is not a thread |
     * | SEND_TTS_MESSAGES        | if channel is not a DM channel and tts is set to true         |
     * | SEND_MESSAGES_IN_THREADS | if channel is a thread                                        |
     *
     * @example
     * // Make a bot say "hi" within a channel
     * // createMessage sends the passed data as content, when you give it a string
     * const client = new SnowTransfer("TOKEN")
     * client.channel.createMessage("channel id", "hi")
     *
     * @example
     * // Send a rich embed object
     * const client = new SnowTransfer("TOKEN")
     * const embedData = {
     * 	title: "This is a nice embed",
     * 	description: "But winter is so cold",
     * 	fields: [
     * 		{ name: "Brr", value: "Insert snowflake emoji here" }
     * 	]
     * }
     * client.channel.createMessage("channel id", { embeds: [embedData] })
     *
     * @example
     * // Send a file with a comment
     * const client = new SnowTransfer("TOKEN")
     * // fileData will be a buffer with the data of the png image.
     * const fileData = fs.readFileSync("nice_picture.png") // You should probably use fs.promises.readFile, since it is asynchronous, synchronous methods block the thread.
     * client.channel.createMessage("channel id", { content: "This is a nice picture", files: [{ name: "Optional_Filename.png", file: fileData }] })
     */
    createMessage(channelId: string, data: string | RESTPostAPIChannelMessageJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }, options?: {
        disableEveryone?: boolean;
    }): Promise<RESTPostAPIChannelMessageResult>;
    /**
     * Creates a new voice Message within a channel or thread
     * @param channelId Id of the Channel or thread to send a message to
     * @param data Buffer of the audio file to send. Tested file types are ogg, mp3, m4a, wav, flac. Other file types work, but some can only be embedded on mobile. Try it and see:tm:
     * @param audioDurationSeconds The duration of the audio file in seconds
     * @param waveform A preview of the entire voice message, with 1 byte per datapoint encoded in base64. Clients sample the recording at most once per 100 milliseconds, but will downsample so that no more than 256 datapoints are in the waveform. If you have no clue what you're doing, leave this as an empty string
     * @returns non editable [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * | Permissions needed       | Condition                                                     |
     * |--------------------------|---------------------------------------------------------------|
     * | VIEW_CHANNEL             | if channel is not a DM channel                                |
     * | READ_MESSAGE_HISTORY     | if channel is not a DM channel and message is a reply         |
     * | SEND_MESSAGES            | if channel is not a DM channel and if channel is not a thread |
     * | SEND_MESSAGES_IN_THREADS | if channel is a thread                                        |
     *
     * @example
     * // Send a voice message that has a duration of 6 seconds
     * const client = new SnowTransfer("TOKEN")
     * // fileData will be a buffer with the data of the ogg audio
     * const fileData = fs.readFileSync("6-second-long-audio.ogg") // You should probably use fs.promises.readFile, since it is asynchronous, synchronous methods block the thread.
     * client.channel.createVoiceMessage("channel id", fileData, 6)
     */
    createVoiceMessage(channelId: string, data: Buffer, audioDurationSeconds: number, waveform?: string): Promise<RESTPostAPIChannelMessageResult>;
    /**
     * Crosspost a message in a news channel to all following channels
     * @param channelId Id of the news channel
     * @param messageId Id of the message
     * @returns [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * | Permissions needed | Condition                                      |
     * |--------------------|------------------------------------------------|
     * | VIEW_CHANNEL       | always                                         |
     * | SEND_MESSAGES      | if the message was sent by the current user    |
     * | MANAGE_MESSAGES    | if the message wasn't sent by the current user |
     *
     * @example
     * // Crosspost a message
     * const client = new SnowTransfer("TOKEN")
     * client.channel.crosspostMessage("channel id", "message id")
     */
    crosspostMessage(channelId: string, messageId: string): Promise<RESTPostAPIChannelMessageCrosspostResult>;
    /**
     * Adds a reaction to a message
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param emoji uri encoded reaction emoji to add
     * you may either use a discord emoji in the format `:emoji_name:emoji_id` or a unicode emoji,
     * which can be found [here](http://www.unicode.org/emoji/charts/full-emoji-list.html)
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed   | Condition                                                                          |
     * |----------------------|------------------------------------------------------------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel                                                     |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel                                                     |
     * | ADD_REACTIONS        | When no other user has reacted with the emoji used and channel is not a DM channel |
     *
     * @example
     * // This example uses a discord emoji
     * const client = new SnowTransfer("TOKEN")
     * client.channel.createReaction("channel Id", "message Id", encodeURIComponent("awooo:322522663304036352"))
     *
     * @example
     * // using a utf-8 emoji
     * const client = new SnowTransfer("TOKEN")
     * client.channel.createReaction("channel Id", "message Id", encodeURIComponent("ðŸ˜€"))
     */
    createReaction(channelId: string, messageId: string, emoji: string): Promise<RESTPutAPIChannelMessageReactionResult>;
    /**
     * Delete a reaction added by the current user from a message
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param emoji reaction emoji
     * @returns Resolves the Promise on successful execution
     *
     * | Permission           | Condition                      |
     * |----------------------|--------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel |
     *
     * @example
     * // This example uses a discord emoji
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteReactionSelf("channel Id", "message Id", encodeURIComponent("awooo:322522663304036352"))
     *
     * @example
     * // using a utf-8 emoji
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteReactionSelf("channel Id", "message Id", encodeURIComponent("ðŸ˜€"))
     */
    deleteReactionSelf(channelId: string, messageId: string, emoji: string): Promise<RESTDeleteAPIChannelMessageUserReactionResult>;
    /**
     * Delete a reaction from a message in a guild channel
     * @param channelId Id of the guild channel
     * @param messageId Id of the message
     * @param emoji reaction emoji
     * @param userId Id of the user
     * @returns Resolves the Promise on successful execution
     *
     * | Permission           | Condition |
     * |----------------------|-----------|
     * | MANAGE_MESSAGES      | always    |
     * | VIEW_CHANNEL         | always    |
     * | READ_MESSAGE_HISTORY | always    |
     *
     * @example
     * // This example uses a discord emoji
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteReaction("channel Id", "message Id", encodeURIComponent("awooo:322522663304036352"), "user Id")
     *
     * @example
     * // using a utf-8 emoji
     * const client = new SnowTransfer("TOKEN")
     * // If a user Id is not supplied, the emoji from that message will be removed for all users
     * client.channel.deleteReaction("channel Id", "message Id", encodeURIComponent("ðŸ˜€"))
     */
    deleteReaction(channelId: string, messageId: string, emoji: string): Promise<RESTDeleteAPIChannelMessageReactionResult>;
    deleteReaction(channelId: string, messageId: string, emoji: string, userId: string): Promise<RESTDeleteAPIChannelMessageUserReactionResult>;
    /**
     * Get a list of users that reacted with a certain emoji on a certain message
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param emoji reaction emoji
     * @param options Options for getting users
     * @returns Array of [user objects](https://discord.com/developers/docs/resources/user#user-object)
     *
     * | Permissions needed   | Condition                      |
     * |----------------------|--------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel |
     *
     * @example
     * // This example uses a discord emoji
     * const client = new SnowTransfer("TOKEN")
     * const reactions = await client.channel.getReactions("channel Id", "message Id", encodeURIComponent("awooo:322522663304036352"))
     */
    getReactions(channelId: string, messageId: string, emoji: string, options?: RESTGetAPIChannelMessageReactionUsersQuery): Promise<RESTGetAPIChannelMessageReactionUsersResult>;
    /**
     * Delete all reactions from a message in a guild channel
     * @param channelId Id of the guild channel
     * @param messageId Id of the message
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed   | Condition |
     * |----------------------|-----------|
     * | VIEW_CHANNEL         | always    |
     * | READ_MESSAGE_HISTORY | always    |
     * | MANAGE_MESSAGES      | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteAllReactions("channel Id", "message Id")
     */
    deleteAllReactions(channelId: string, messageId: string): Promise<RESTDeleteAPIChannelAllMessageReactionsResult>;
    /**
     * Edit a message sent by the current user or edit the message flags of another user's message
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param data Data to send
     * @param options Options for editing this message
     * @returns [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * | Permissions needed | Condition                                        |
     * |--------------------|--------------------------------------------------|
     * | VIEW_CHANNEL       | if channel is not a DM channel                   |
     * | MANAGE_MESSAGES    | When editing someone else's message to set flags |
     *
     * @example
     * // Simple ping response
     * const client = new SnowTransfer("TOKEN")
     * const time = Date.now()
     * const message = await client.channel.createMessage("channel id", "pong")
     * client.channel.editMessage("channel id", message.id, `pong ${Date.now() - time}ms`)
     */
    editMessage(channelId: string, messageId: string, data: string | RESTPatchAPIChannelMessageJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }, options?: {
        disableEveryone?: boolean;
    }): Promise<RESTPatchAPIChannelMessageResult>;
    /**
     * Delete a message
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param reason Reason for deleting the message
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition                                    |
     * |--------------------|----------------------------------------------|
     * | VIEW_CHANNEL       | if channel is not a DM channel               |
     * | MANAGE_MESSAGES    | When the bot isn't the author of the message |
     *
     * @example
     * // Delete a message
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteMessage("channel id", "message id")
     */
    deleteMessage(channelId: string, messageId: string, reason?: string): Promise<RESTDeleteAPIChannelMessageResult>;
    /**
     * Bulk delete messages from a guild channel, messages may not be older than 2 weeks
     * @param channelId Id of the guild channel
     * @param messages array of message ids to delete
     * @param reason Reason for deleting the messages
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | VIEW_CHANNEL       | always    |
     * | MANAGE_MESSAGES    | always    |
     *
     * @example
     * // Bulk deletes 2 messages with a reason of "spam"
     * const client = new SnowTransfer("TOKEN")
     * client.channel.bulkDeleteMessages("channel id", ["message id 1", "message id 2"], "spam")
     */
    bulkDeleteMessages(channelId: string, messages: Array<string>, reason?: string): Promise<RESTPostAPIChannelMessagesBulkDeleteResult>;
    /**
     * Modify the permission overwrites of a guild channel
     * @param channelId Id of the guild channel
     * @param permissionId Id of the permission overwrite
     * @param data modified [permission overwrite](https://discord.com/developers/docs/resources/channel#edit-channel-permissions-json-params) object
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition                  |
     * |--------------------|----------------------------|
     * | MANAGE_CHANNELS    | if channel is not a thread |
     * | MANAGE_THREADS     | if channel is a thread     |
     * | MANAGE_ROLES       | always                     |
     * | VIEW_CHANNEL       | always                     |
     *
     * @example
     * // Edits the permissions of a user to allow viewing the channel only
     * const client = new SnowTransfer("TOKEN")
     * client.channel.editChannelPermission("channel id", "user id", { allow: String(1 << 10), type: 1 })
     */
    editChannelPermission(channelId: string, permissionId: string, data: RESTPutAPIChannelPermissionJSONBody & {
        reason?: string;
    }): Promise<RESTPutAPIChannelPermissionResult>;
    /**
     * Get a list of invites for a guild channel
     * @param channelId Id of the guild channel
     * @returns Array of [invite objects](https://discord.com/developers/docs/resources/invite#invite-object) (with metadata)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | VIEW_CHANNEL       | always    |
     * | MANAGE_CHANNELS    | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const invites = await client.channel.getChannelInvites("channel id")
     */
    getChannelInvites(channelId: string): Promise<RESTGetAPIChannelInvitesResult>;
    /**
     * Create an invite for a guild channel
     *
     * If no data argument is passed, the invite will be created with the defaults
     * @param channelId Id of the channel
     * @param data invite data (optional)
     * @returns [Invite object](https://discord.com/developers/docs/resources/invite#invite-object) (with metadata)
     *
     * | Permissions needed    | Condition |
     * |-----------------------|-----------|
     * | VIEW_CHANNEL          | always    |
     * | CREATE_INSTANT_INVITE | always    |
     *
     * @example
     * // Creates a unique permanent invite with infinite uses
     * const client = new SnowTransfer("TOKEN")
     * const invite = await client.channel.createChannelInvite("channel id", { max_age: 0, max_uses: 0, unique: true })
     */
    createChannelInvite(channelId: string, data?: RESTPostAPIChannelInviteJSONBody & {
        reason?: string;
    }): Promise<RESTPostAPIChannelInviteResult>;
    /**
     * Delete a permission overwrite from a guild channel
     * @param channelId Id of the guild channel
     * @param permissionId Id of the permission overwrite
     * @param reason Reason for deleting the permission
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition                  |
     * |--------------------|----------------------------|
     * | MANAGE_CHANNELS    | if channel is not a thread |
     * | MANAGE_THREADS     | if channel is a thread     |
     * | MANAGE_ROLES       | always                     |
     * | VIEW_CHANNEL       | always                     |
     *
     * @example
     * // Deletes the permission overwrite of a user
     * const client = new SnowTransfer("TOKEN")
     * client.channel.deleteChannelPermission("channel id", "user id", "Abusing channel")
     */
    deleteChannelPermission(channelId: string, permissionId: string, reason?: string): Promise<RESTDeleteAPIChannelPermissionResult>;
    /**
     * Follow a news channel to another channel
     * @param channelId The Id of the news channel
     * @param webhookChannelId The Id of the channel messages will be sent to
     * @returns A [followed channel](https://discord.com/developers/docs/resources/channel#followed-channel-object) object
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_WEBHOOKS    | always    |
     *
     * @example
     * // Follows an announcement channel to a text channel
     * const client = new SnowTransfer("TOKEN")
     * client.channel.followAnnouncementChannel("news channel id", "text channel id")
     */
    followAnnouncementChannel(channelId: string, webhookChannelId: string): Promise<RESTPostAPIChannelFollowersResult>;
    /**
     * Send an indicator that the current user is typing within a channel.
     *
     * **You should generally avoid this method unless used for longer computations (>1s)**
     * @param channelId Id of the channel
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed       | Condition                      |
     * |--------------------------|--------------------------------|
     * | VIEW_CHANNEL             | if channel is not a DM channel |
     * | SEND_MESSAGES            | if channel is not a thread     |
     * | SEND_MESSAGES_IN_THREADS | if channel is a thread         |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.channel.sendChannelTyping("channel id")
     */
    startChannelTyping(channelId: string): Promise<RESTPostAPIChannelTypingResult>;
    /**
     * Get a list of pinned messages for a channel
     * @param channelId Id of the channel
     * @returns Array of [message objects](https://discord.com/developers/docs/resources/channel#message-object)
     *
     * | Permissions needed   | Condition                      |
     * |----------------------|--------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const messages = await client.channel.getPinnedMessages("channel id")
     */
    getChannelPinnedMessages(channelId: string): Promise<RESTGetAPIChannelPinsResult>;
    /**
     * Pin a message within a channel
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param reason Reason for pinning the message
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed   | Condition                      |
     * |----------------------|--------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel |
     * | MANAGE_MESSAGES      | if channel is not a DM channel |
     *
     * @example
     * // Pin a message because it was a good meme
     * const client = new SnowTransfer("TOKEN")
     * client.channel.addChannelPinnedMessage("channel id", "message id", "Good meme")
     */
    addChannelPinnedMessage(channelId: string, messageId: string, reason?: string): Promise<RESTPutAPIChannelPinResult>;
    /**
     * Remove a pinned message from a channel
     * @param channelId Id of the channel
     * @param messageId Id of the message
     * @param reason Reason for removing the pinned message
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed   | Condition                      |
     * |----------------------|--------------------------------|
     * | VIEW_CHANNEL         | if channel is not a DM channel |
     * | READ_MESSAGE_HISTORY | if channel is not a DM channel |
     * | MANAGE_MESSAGES      | if channel is not a DM channel |
     *
     * @example
     * // Remove a pinned message because mod abuse :(
     * const client = new SnowTransfer("TOKEN")
     * client.channel.removeChannelPinnedMessage("channel id", "message id", "Mod abuse")
     */
    removeChannelPinnedMessage(channelId: string, messageId: string, reason?: string): Promise<RESTDeleteAPIChannelPinResult>;
    /**
     * Creates a public thread off a message in a guild channel
     * @param channelId Id of the guild channel
     * @param messageId Id of the message
     * @param options Thread meta data
     * @returns [thread channel](https://discord.com/developers/docs/resources/channel#channel-object) object
     *
     * | Permissions needed    | Condition |
     * |-----------------------|-----------|
     * | VIEW_CHANNEL          | always    |
     * | CREATE_PUBLIC_THREADS | always    |
     *
     * @example
     * // Create a thread off a cool art piece to discuss
     * const client = new SnowTransfer("TOKEN")
     * const thread = await client.channel.createThreadWithMessage("channel id", "message id", { name: "cool-art", reason: "I wanna talk about it!" })
     */
    createThreadWithMessage(channelId: string, messageId: string, options: RESTPostAPIChannelMessagesThreadsJSONBody & {
        reason?: string;
    }): Promise<RESTPostAPIChannelMessagesThreadsResult>;
    /**
     * Creates a thread under a guild channel without a message
     * @param channelId Id of the guild channel
     * @param options Thread meta data
     * @returns [thread channel](https://discord.com/developers/docs/resources/channel#channel-object) object
     *
     * | Permissions needed     | Condition                    |
     * |------------------------|------------------------------|
     * | VIEW_CHANNEL           | always                       |
     * | CREATE_PUBLIC_THREADS  | if creating a public thread  |
     * | CREATE_PRIVATE_THREADS | if creating a private thread |
     *
     * @example
     * // Creates a private thread that's invitable to talk about someone's birthday
     * const client = new SnowTransfer("TOKEN")
     * const thread = await client.channel.createThreadWithoutMessage("channel id", { name: "persons-birthday", type: 12, invitable: true, reason: "Shh! It's a surprise" })
     */
    createThreadWithoutMessage(channelId: string, options: Omit<RESTPostAPIChannelThreadsJSONBody, "type"> & {
        type: 10;
        reason?: string;
    }): Promise<APITextBasedChannel<ChannelType.AnnouncementThread>>;
    createThreadWithoutMessage(channelId: string, options: Omit<RESTPostAPIChannelThreadsJSONBody, "type"> & {
        type: 11;
        reason?: string;
    }): Promise<APITextBasedChannel<ChannelType.PublicThread>>;
    createThreadWithoutMessage(channelId: string, options: Omit<RESTPostAPIChannelThreadsJSONBody, "type"> & {
        type: 12;
        reason?: string;
    }): Promise<APITextBasedChannel<ChannelType.PrivateThread>>;
    /**
     * Join a thread
     * @param threadId Id of the thread
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | VIEW_CHANNEL       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.channel.joinThread("thread id")
     */
    joinThread(threadId: string): Promise<RESTPutAPIChannelThreadMembersResult>;
    /**
     * Add a user to a thread
     *
     * CurrentUser must be a member of the thread
     * @param threadId Id of the thread
     * @param userId Id of the user to add
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed          | Condition |
     * |-----------------------------|-----------|
     * | CurrentUser added to Thread | always    |
     * | SEND_MESSAGES_IN_THREADS    | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.channel.addThreadMember("thread id", "user id")
     */
    addThreadMember(threadId: string, userId: string): Promise<RESTPutAPIChannelThreadMembersResult>;
    /**
     * Leave a thread
     * @param threadId Id of the thread
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.channel.leaveThread("thread id")
     */
    leaveThread(threadId: string): Promise<RESTDeleteAPIChannelThreadMembersResult>;
    /**
     * Remove a user from a thread
     * @param threadId Id of the thread
     * @param userId Id of the user to remove
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition                                            |
     * |--------------------|------------------------------------------------------|
     * | MANAGE_THREADS     | if the current user is not the creator of the thread |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.channel.removeThreadMember("thread id", "user id")
     */
    removeThreadMember(threadId: string, userId: string): Promise<RESTDeleteAPIChannelThreadMembersResult>;
    /**
     * Gets a member of a thread
     * @param threadId Id of the thread
     * @param userId Id of the user
     * @param withMember If a member object should be present
     * @returns A [thread member](https://discord.com/developers/docs/resources/channel#thread-member-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | VIEW_CHANNEL       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const member = await client.channel.getThreadMember("thread id", "user id")
     */
    getThreadMember(threadId: string, userId: string, withMember?: boolean): Promise<RESTGetAPIChannelThreadMemberResult>;
    /**
     * Gets all members within a thread
     * @param channelId Id of the Thread
     * @param options Options for getting members
     * @returns Array of [thread members](https://discord.com/developers/docs/resources/channel#thread-member-object)
     *
     * | Permissions needed           | Condition |
     * |------------------------------|-----------|
     * | VIEW_CHANNEL                 | always    |
     *
     * | Intents       |
     * |---------------|
     * | GUILD_MEMBERS |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const members = await client.channel.getThreadMembers("thread id")
     */
    getThreadMembers(channelId: string, options?: RESTGetAPIChannelThreadMembersQuery): Promise<RESTGetAPIChannelThreadMembersResult>;
    /**
     * Gets all threads that are public and archived within a guild channel
     * @param channelId Id of the guild channel
     * @param options Options for getting threads
     * @returns Object containing [public threads](https://discord.com/developers/docs/resources/channel#channel-object), [thread members](https://discord.com/developers/docs/resources/channel#thread-member-object) of the CurrentUser, and if there are more results in the pagination
     *
     * | Permissions needed          | Condition |
     * |-----------------------------|-----------|
     * | VIEW_CHANNEL                | always    |
     * | READ_MESSAGE_HISTORY        | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const result = await client.channel.getChannelArchivedPublicThreads("channel id")
     */
    getChannelArchivedPublicThreads(channelId: string, options?: RESTGetAPIChannelThreadsArchivedQuery): Promise<RESTGetAPIChannelThreadsArchivedPublicResult>;
    /**
     * Gets all threads that are private and archived within a guild channel
     *
     * CurrentUser must be a member of the thread if they do not have MANAGE_THREADS permissions
     * @param channelId Id of the Channel
     * @param options Options for getting threads
     * @returns Object containing [private threads](https://discord.com/developers/docs/resources/channel#channel-object), [thread members](https://discord.com/developers/docs/resources/channel#thread-member-object) of the CurrentUser, and if there are more results in the pagination
     *
     * | Permissions needed          | Condition                            |
     * |-----------------------------|--------------------------------------|
     * | VIEW_CHANNEL                | always                               |
     * | READ_MESSAGE_HISTORY        | always                               |
     * | MANAGE_THREADS              | if CurrentUser isn't added to Thread |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const result = await client.channel.getChannelArchivedPrivateThreads("channel id")
     */
    getChannelArchivedPrivateThreads(channelId: string, options?: RESTGetAPIChannelThreadsArchivedQuery): Promise<RESTGetAPIChannelThreadsArchivedPrivateResult>;
    /**
     * Gets all threads that are private and archived within a guild channel that the CurrentUser is apart of
     *
     * CurrentUser must be a member of the thread if they do not have MANAGE_THREADS permissions
     * @param channelId Id of the Channel
     * @param options Option for getting threads
     * @returns Object containing [private threads](https://discord.com/developers/docs/resources/channel#channel-object), [thread members](https://discord.com/developers/docs/resources/channel#thread-member-object) of the CurrentUser, and if there are more results in the pagination
     *
     * | Permissions needed                | Condition                                  |
     * |-----------------------------------|--------------------------------------------|
     * | VIEW_CHANNEL                      | always                                     |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const result = await client.channel.getChannelArchivedPrivateThreadsUser("channel id")
     */
    getChannelArchivedPrivateThreadsUser(channelId: string, options?: RESTGetAPIChannelThreadsArchivedQuery): Promise<RESTGetAPIChannelUsersThreadsArchivedResult>;
}

/**
 * Methods for interacting with emojis
 */
declare class GuildAssetsMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new GuildAssets Method handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.guildAssets.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get a list of emojis of a guild
     * @param guildId Id of the guild
     * @returns Array of [emoji objects](https://discord.com/developers/docs/resources/emoji#emoji-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const emojis = await client.guildAssets.getEmojis("guild id")
     */
    getEmojis(guildId: string): Promise<RESTGetAPIGuildEmojisResult>;
    /**
     * Get an emoji via guildId + emojiId
     * @param guildId Id of the guild
     * @param emojiId Id of the emoji
     * @returns [Emoji object](https://discord.com/developers/docs/resources/emoji#emoji-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const emoji = await client.guildAssets.getEmoji("guild id", "emoji id")
     */
    getEmoji(guildId: string, emojiId: string): Promise<RESTGetAPIGuildEmojiResult>;
    /**
     * Create a new Emoji
     * @param guildId Id of the guild
     * @param data Emoji data, check the example
     * @returns [Emoji object](https://discord.com/developers/docs/resources/emoji#emoji-object)
     *
     * | Permissions needed         | Condition |
     * |----------------------------|-----------|
     * | MANAGE_EMOJIS_AND_STICKERS | always    |
     *
     * @example
     * // upload a simple png emoji with a name of "niceEmoji"
     * const client = new SnowTransfer("TOKEN")
     * const fileData = fs.readFileSync("nice_emoji.png") // You should probably use fs.promises.readFile, since it is asynchronous, synchronous methods pause the thread.
     * const emojiData = \{
     * 	name: "niceEmoji",
     * 	image: `data:image/png;base64,${fileData.toString("base64")}` // base64 data url: data:mimetype;base64,base64String
     * \}
     * client.guildAssets.createEmoji("guild id", emojiData)
     */
    createEmoji(guildId: string, data: RESTPostAPIGuildEmojiJSONBody & {
        reason?: string;
    }): Promise<RESTPostAPIGuildEmojiResult>;
    /**
     * Update an existing emoji
     * @param {string} guildId Id of the guild
     * @param {string} emojiId Id of the emoji
     * @param {object} data Emoji data
     * @returns [Emoji object](https://discord.com/developers/docs/resources/emoji#emoji-object)
     *
     * | Permissions needed         | Condition |
     * |----------------------------|-----------|
     * | MANAGE_EMOJIS_AND_STICKERS | always    |
     *
     * @example
     * // Change the name of an existing emoji to "niceEmote"
     * const client = new SnowTransfer("TOKEN")
     * const emojiData = {
     * 	name: "niceEmote"
     * }
     * client.guildAssets.updateEmoji("guild id", "emoji id", emojiData)
     */
    updateEmoji(guildId: string, emojiId: string, data: RESTPatchAPIGuildEmojiJSONBody & {
        reason?: string;
    }): Promise<RESTPatchAPIGuildEmojiResult>;
    /**
     * Delete an emoji
     * @param guildId Id of the guild
     * @param emojiId Id of the emoji
     * @param reason Reason for deleting the emoji
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed         | Condition |
     * |----------------------------|-----------|
     * | MANAGE_EMOJIS_AND_STICKERS | always    |
     *
     * @example
     * // Deletes an emoji because it wasn't nice
     * const client = new SnowTransfer("TOKEN")
     * client.guildAssets.deleteEmoji("guild id", "emoji id", "wasn't nice")
     */
    deleteEmoji(guildId: string, emojiId: string, reason?: string): Promise<RESTDeleteAPIGuildEmojiResult>;
    /**
     * Get a global sticker
     * @param stickerId Id of the sticker
     * @returns [Sticker object](https://discord.com/developers/docs/resources/sticker#sticker-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const sticker = await client.guildAssets.getSticker("sticker id")
     */
    getSticker(stickerId: string): Promise<RESTGetAPIStickerResult>;
    /**
     * Get all guild stickers
     * @param guildId Id of the guild
     * @returns An Array of [sticker objects](https://discord.com/developers/docs/resources/sticker#sticker-object)
     *
     * | Permissions needed         | Condition                                   |
     * |----------------------------|---------------------------------------------|
     * | MANAGE_EMOJIS_AND_STICKERS | if the CurrentUser desires the `user` field |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const stickers = await client.guildAssets.getGuildStickers("guild id")
     */
    getGuildStickers(guildId: string): Promise<RESTGetAPIGuildStickersResult>;
    /**
     * Get a guild sticker
     * @param guildId Id of the guild
     * @param stickerId Id of the sticker
     * @returns A [sticker object](https://discord.com/developers/docs/resources/sticker#sticker-object)
     *
     * | Permissions needed         | Condition                                   |
     * |----------------------------|---------------------------------------------|
     * | MANAGE_EMOJIS_AND_STICKERS | if the CurrentUser desires the `user` field |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const sticker = await client.guildAssets.getGuildSticker("guild id", "sticker id")
     */
    getGuildSticker(guildId: string, stickerId: string): Promise<RESTGetAPIGuildStickerResult>;
    /**
     * Create a guild sticker
     * @param guildId Id of the guild
     * @param data Sticker data
     * @returns A [sticker object](https://discord.com/developers/docs/resources/sticker#sticker-object)
     *
     * | Permissions needed          | Condition                                       |
     * |-----------------------------|-------------------------------------------------|
     * | MANAGE_EMOJIS_AND_STICKERS  | always                                          |
     *
     * | Guild Features needed | Condition                                       |
     * |-----------------------|-------------------------------------------------|
     * | VERIFIED or PARTNERED | If CurrentUser tries to create a LOTTIE sticker |
     *
     * @example
     * // Creates a LOTTIE sticker
     * const client = new SnowTransfer("TOKEN")
     * const fileData = fs.readFileSync("nice_sticker.json") // You should probably use fs.promises.readFile, since it is asynchronous, synchronous methods pause the thread.
     * const stickerData = {
     * 	name: "niceSticker",
     * 	file: fileData,
     * 	description: "A very nice sticker",
     * 	tags: ["nice", "sticker"],
     * }
     * const sticker = await client.guildAssets.createGuildSticker("guild id", stickerData)
     */
    createGuildSticker(guildId: string, data: RESTPostAPIGuildStickerFormDataBody & {
        file: Buffer | Blob | File | Readable | ReadableStream;
        reason?: string;
    }): Promise<RESTPostAPIGuildStickerResult>;
    /**
     * Update a guild sticker
     * @param guildId Id of the guild
     * @param stickerId Id of the sticker
     * @param data Sticker data
     * @returns A [sticker object](https://discord.com/developers/docs/resources/sticker#sticker-object)
     *
     * | Permissions needed         | Condition |
     * |----------------------------|-----------|
     * | MANAGE_EMOJIS_AND_STICKERS | always    |
     *
     * @example
     * // Updates a sticker's name to "nicerSticker"
     * const client = new SnowTransfer("TOKEN")
     * const sticker = await client.guildAssets.updateGuildSticker("guild id", "sticker id", { name: "nicerSticker", reason: "because it was nicer" })
     */
    updateGuildSticker(guildId: string, stickerId: string, data: RESTPatchAPIGuildStickerJSONBody & {
        reason?: string;
    }): Promise<RESTPatchAPIGuildStickerResult>;
    /**
     * Delete a guild sticker
     * @param guildId Id of the guild
     * @param stickerId Id of the sticker
     * @param reason Reason for deleting the sticker
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed         | Condition |
     * |----------------------------|-----------|
     * | MANAGE_EMOJIS_AND_STICKERS | always    |
     *
     * @example
     * // Deletes a sticker because it was too nice
     * const client = new SnowTransfer("TOKEN")
     * client.guildAssets.deleteGuildSticker("guild id", "sticker id", "It was too nice")
     */
    deleteGuildSticker(guildId: string, stickerId: string, reason?: string): Promise<RESTDeleteAPIGuildStickerResult>;
}

/**
 * Methods for interacting with Guilds
 */
declare class GuildMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Guild Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.guild.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Create a new Guild, **limited to 10 guilds (you may create more if you are whitelisted)**
     * Check the [discord docs](https://discord.com/developers/docs/resources/guild#create-guild) for more infos
     * @param data Data for the new guild
     * @returns [Guild](https://discord.com/developers/docs/resources/guild#guild-object)
     *
     * @example
     * // Creates a simple guild with the name "Demo Guild"
     * const client = new SnowTransfer("TOKEN")
     * const guildData = {
     * 	name: "Demo Guild"
     * }
     * const guild = await client.guild.createGuild(guildData)
     */
    createGuild(data: RESTPostAPIGuildsJSONBody): Promise<RESTPostAPIGuildsResult>;
    /**
     * Get a guild via Id
     *
     * CurrentUser must be a member of the guild
     * @param guildId Id of the guild
     * @param withCounts when true, will return approximate member and presence counts for the guild
     * @returns [Guild object](https://discord.com/developers/docs/resources/guild#guild-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const guild = await client.guild.getGuild("guild id")
     */
    getGuild(guildId: string, withCounts?: boolean): Promise<RESTGetAPIGuildResult>;
    /**
     * Gets a guild's preview. If the CurrentUser is not in the guild, the guild must be lurkable
     * @param guildId Id of the guild
     * @returns [Guild preview](https://discord.com/developers/docs/resources/guild#guild-preview-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const guildPreview = await client.guild.getGuildPreview("guild id")
     */
    getGuildPreview(guildId: string): Promise<RESTGetAPIGuildPreviewResult>;
    /**
     * Update a guild
     * @param guildId Id of the guild
     * @param data Updated guild data
     * @returns [Guild object](https://discord.com/developers/docs/resources/guild#guild-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * // Update the name of a guild to "Nice Guild"
     * const client = new SnowTransfer("TOKEN")
     * const guildData = {
     * 	name: "Nice Guild"
     * }
     * client.guild.updateGuild("guild Id", guildData)
     */
    updateGuild(guildId: string, data: RESTPatchAPIGuildJSONBody): Promise<RESTPatchAPIGuildResult>;
    /**
     * Delete a guild
     *
     * CurrentUser must be the owner of the guild
     *
     * **This action is irreversible, so use it with caution!**
     * @param guildId Id of the guild
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.guild.deleteGuild("guild id")
     */
    deleteGuild(guildId: string): Promise<RESTDeleteAPIGuildResult>;
    /**
     * Get a list of all channels for a guild. Does not include threads
     *
     * CurrentUser must be a member of the guild
     * @param guildId Id of the guild
     * @returns list of [channels](https://discord.com/developers/docs/resources/channel#channel-object-channel-structure)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const channels = await client.guild.getGuildChannels("guild id")
     */
    getGuildChannels(guildId: string): Promise<RESTGetAPIGuildChannelsResult>;
    /**
     * Create a channel within a guild
     * @param guildId Id of the guild
     * @param data channel properties
     * @returns [channel object](https://discord.com/developers/docs/resources/channel#channel-object-channel-structure)
     *
     * | Permissions needed | Condition                                                       |
     * |--------------------|-----------------------------------------------------------------|
     * | MANAGE_CHANNELS    | always                                                          |
     * | ADMINISTRATOR      | setting MANAGE_ROLES in permission_overwrites                   |
     * | *                  | if setting * permission in overwrites where * is any permission |
     *
     * @example
     * // Creates a guild voice channel with the name "nice voice channel" and with permission connect denied for the @everyone role
     * const client = new SnowTransfer("TOKEN")
     * const channelData = \{
     * 	name: "nice voice channel",
     * 	type: 2,
     * 	permission_overwrites: [\{ id: "guild id", type: 0, allow: "0" deny: (BigInt(1) << BigInt(20)).toString() \}]
     * \}
     * const channel = await client.guild.createGuildChannel("guild id", channelData)
     */
    createGuildChannel(guildId: string, data: RESTPostAPIGuildChannelJSONBody): Promise<RESTPostAPIGuildChannelResult>;
    /**
     * Batch update the positions of channels. Only those being moved needs to be included here
     * @param guildId Id of the guild
     * @param data Positional data to send
     * @param reason Reason for updating the channels' positions
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_CHANNELS    | always    |
     *
     * @example
     * // Sets the position of a channel to 2 under a category channel
     * const client = new SnowTransfer("TOKEN")
     * client.guild.updateChannelPositions("guild id", [{ id: "channel id", position: 2, parent_id: "category id" }], "they looked out of order")
     */
    updateChannelPositions(guildId: string, data: RESTPatchAPIGuildChannelPositionsJSONBody, reason?: string): Promise<RESTPatchAPIGuildChannelPositionsResult>;
    /**
     * Returns all active threads in the guild, including public and private threads. Threads are ordered by their `id`, in descending order
     * @param guildId Id of the guild
     * @returns All active threads and member objects of the CurrentUser that the CurrentUser has access to.
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const threads = await client.guild.listActiveThreads("guild id")
     */
    listActiveThreads(guildId: string): Promise<RESTGetAPIGuildThreadsResult>;
    /**
     * Get a guild member via Id
     *
     * CurrentUser must be a member of the guild
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @returns [guild member](https://discord.com/developers/docs/resources/guild#guild-member-object-guild-member-structure)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const member = await client.guild.getGuildMember("guild id", "member id")
     */
    getGuildMember(guildId: string, memberId: string): Promise<RESTGetAPIGuildMemberResult>;
    /**
     * Get a list of guild members
     *
     * CurrentUser must be a member of the guild
     * @param guildId Id of the guild
     * @param options query data
     * @returns list of [guild members](https://discord.com/developers/docs/resources/guild#guild-member-object-guild-member-structure)
     *
     * | Intents       |
     * |---------------|
     * | GUILD_MEMBERS |
     *
     * @example
     * // Gets 10 members from a guild
     * const client = new SnowTransfer("TOKEN")
     * const members = await client.guild.getGuildMembers("guild id", { limit: 10 })
     */
    getGuildMembers(guildId: string, options?: RESTGetAPIGuildMembersQuery): Promise<RESTGetAPIGuildMembersResult>;
    /**
     * Get a list of guild members that match a query
     * @param guildId Id of the guild
     * @param options query data
     * @returns list of [guild members](https://discord.com/developers/docs/resources/guild#guild-member-object-guild-member-structure)
     *
     * @example
     * // Gets all members with the username "Wolke"
     * const client = new SnowTransfer("TOKEN")
     * const members = await client.guild.searchGuildMembers("guild id", { query: "Wolke" })
     */
    searchGuildMembers(guildId: string, options: RESTGetAPIGuildMembersSearchQuery): Promise<RESTGetAPIGuildMembersSearchResult>;
    /**
     * Add a guild member to a guild via oauth2 access token
     *
     * CurrentUser must be a member of the guild
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param data object containing the needed request data
     * @returns [guild member](https://discord.com/developers/docs/resources/guild#guild-member-object-guild-member-structure) or void if the member is already in the guild
     *
     * | Permissions needed    | Condition |
     * |-----------------------|-----------|
     * | CREATE_INSTANT_INVITE | always    |
     *
     * | OAUTH2 Scopes |
     * |---------------|
     * | guilds.join   |
     *
     * @example
     * // add a user to a server
     * const client = new SnowTransfer("TOKEN")
     * const memberData = {
     * 	access_token: "access token of a user with the guilds.join scope"
     * }
     * client.guild.addGuildMember("guildId", "memberId", memberData)
     */
    addGuildMember(guildId: string, memberId: string, data: RESTPutAPIGuildMemberJSONBody): Promise<RESTPutAPIGuildMemberResult>;
    /**
     * Update properties of a guild member
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param data Updated properties
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition    |
     * |--------------------|--------------|
     * | MANAGE_NICKNAMES   | Nick Updates |
     * | MANAGE_ROLES       | Role Updates |
     * | MUTE_MEMBERS       | Mute Updates |
     * | DEAFEN_MEMBERS     | Deaf Updates |
     * | MOVE_MEMBERS       | Voice Move   |
     * | CONNECT						| Voice Move   |
     * | MODERATE_MEMBERS   | Timeouts     |
     *
     * @example
     * // Reset the nickname of a guild member
     * const client = new SnowTransfer("TOKEN")
     * const memberData = {
     * 	nick: "" // You can reset nicknames by providing an empty string as the value of data.nick
     * }
     * const member = await client.guild.updateGuildMember("guild Id", "memberId", memberData)
     */
    updateGuildMember(guildId: string, memberId: string, data: RESTPatchAPIGuildMemberJSONBody): Promise<RESTPatchAPIGuildMemberResult>;
    /**
     * Update the nick of the CurrentMember
     * @param guildId Id of the guild
     * @param data object with a nick property and optionally, a reason property
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | CHANGE_NICKNAME    | always    |
     *
     * @example
     * // change nick of bot to "Nice Nick"
     * const client = new SnowTransfer("TOKEN")
     * const nickData = {
     * 	nick: "Nice Nick"
     * }
     * client.guild.updateSelf("guildId", nickData)
     */
    updateSelf(guildId: string, data: RESTPatchAPICurrentGuildMemberJSONBody & {
        reason?: string;
    }): Promise<APIGuildMember>;
    /**
     * Add a role to a guild member
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param roleId Id of the role
     * @param reason The reason for the role to be added
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * // add a role to a member with a reason of "I want to add a role"
     * const client = new SnowTransfer("TOKEN")
     * client.guild.addGuildMemberRole("guildId", "memberId", "roleId", "I want to add a role")
     */
    addGuildMemberRole(guildId: string, memberId: string, roleId: string, reason?: string): Promise<RESTPutAPIGuildMemberRoleResult>;
    /**
     * Remove a role from a guild member
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param roleId Id of the role
     * @param reason The reason for the role to be removed
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * // remove a role from a member with a reason of "I want to remove a role"
     * const client = new SnowTransfer("TOKEN")
     * client.guild.removeGuildMemberRole("guildId", "memberId", "roleId", "I want to remove a role")
     */
    removeGuildMemberRole(guildId: string, memberId: string, roleId: string, reason?: string): Promise<RESTDeleteAPIGuildMemberRoleResult>;
    /**
     * Remove a guild member (aka kick them)
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param reason Reason for kicking the member
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | KICK_MEMBERS       | always    |
     *
     * @example
     * // Kick a member with a reason of "spam"
     * const client = new SnowTransfer("TOKEN")
     * client.guild.removeGuildMember("guild Id", "memberId", "spam")
     */
    removeGuildMember(guildId: string, memberId: string, reason?: string): Promise<RESTDeleteAPIGuildMemberResult>;
    /**
     * Get bans of a guild
     * @param guildId Id of the guild
     * @param options Query string options
     * @returns List of [bans](https://discord.com/developers/docs/resources/guild#ban-object-ban-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | BAN_MEMBERS        | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const bans = await client.guild.getGuildBans("guildId")
     */
    getGuildBans(guildId: string, options?: RESTGetAPIGuildBansQuery): Promise<RESTGetAPIGuildBansResult>;
    /**
     * Get a specific ban of a guild member
     * @param guildId Id of the guild
     * @param memberId Id of the member
     * @returns [ban](https://discord.com/developers/docs/resources/guild#ban-object-ban-structure) object
     *
     * @throws a `DiscordAPIError` if the member is not banned
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | BAN_MEMBERS        | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const ban = await client.guild.getGuildBan("guildId", "memberId")
     */
    getGuildBan(guildId: string, memberId: string): Promise<RESTGetAPIGuildBanResult>;
    /**
     * Ban a guild member
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param data object with a reason and a delete_message_days property
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | BAN_MEMBERS        | always    |
     *
     * @example
     * // Ban a user with a reason and delete the last 2 days of their messages
     * const client = new SnowTransfer("TOKEN")
     * const banData = {
     * 	reason: "Memes were not good enough",
     * 	delete_message_days":2
     * }
     * client.guild.createGuildBan("guild Id", "memberId", banData)
     */
    createGuildBan(guildId: string, memberId: string, data?: RESTPutAPIGuildBanJSONBody & {
        reason?: string;
    }): Promise<RESTPutAPIGuildBanResult>;
    /**
     * Remove a ban of a user
     * @param guildId Id of the guild
     * @param memberId Id of the guild member
     * @param reason Reason for removing the ban
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | BAN_MEMBERS        | always    |
     *
     * @example
     * // Remove a ban of a user with a reason
     * const client = new SnowTransfer("TOKEN")
     * client.guild.removeGuildBan("guildId", "memberId", "This guy was cool")
     */
    removeGuildBan(guildId: string, memberId: string, reason?: string): Promise<RESTDeleteAPIGuildBanResult>;
    /**
     * Get a list of roles for a guild
     * @param guildId Id of the guild
     * @returns array of [roles](https://discord.com/developers/docs/topics/permissions#role-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const roles = await client.guild.getGuildRoles("guildId")
     */
    getGuildRoles(guildId: string): Promise<RESTGetAPIGuildRolesResult>;
    /**
     * Create a new Role
     * @param guildId Id of the guild
     * @param data data with role properties
     * @returns [role](https://discord.com/developers/docs/resources/channel#channel-object-channel-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * // Create a role with the name "Nice Role" and a color of a soft blue
     * const client = new SnowTransfer("TOKEN")
     * const roleData = {
     * 	name: "Nice Role",
     * 	color: 0x7c7cf8
     * }
     * client.guild.createGuildRole("guild Id", roleData)
     */
    createGuildRole(guildId: string, data?: RESTPostAPIGuildRoleJSONBody & {
        reason?: string;
    }): Promise<RESTPostAPIGuildRoleResult>;
    /**
     * Modify the positions of roles
     * @param guildId Id of the guild
     * @param data Role data to update
     * @param reason Reason for moving the roles
     * @returns array of [roles](https://discord.com/developers/docs/topics/permissions#role-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const roles = await client.guild.updateGuildRolePositions("guildId", [{ id: "guild id", position: 1 }, { id: "role id 2", position: 2 }])
     */
    updateGuildRolePositions(guildId: string, data: RESTPatchAPIGuildRolePositionsJSONBody, reason?: string): Promise<RESTPatchAPIGuildRolePositionsResult>;
    /**
     * Update a guild role
     * @param guildId Id of the guild
     * @param roleId Id of the role
     * @param data updated properties of the role
     * @returns [Updated Role](https://discord.com/developers/docs/topics/permissions#role-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const roleData = {
     * 	name: "Nicer Role",
     * }
     * client.guild.updateGuildRole("guildId", "roleId", roleData)
     */
    updateGuildRole(guildId: string, roleId: string, data: RESTPatchAPIGuildRoleJSONBody): Promise<RESTPatchAPIGuildRoleResult>;
    /**
     * Delete a role from the guild
     * @param guildId Id of the guild
     * @param roleId Id of the role
     * @param reason Reason for deleting the role
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_ROLES       | always    |
     *
     * @example
     * // Deletes a role with a reason "This role is too cool"
     * const client = new SnowTransfer("TOKEN")
     * client.guild.deleteGuildRole("guildId", "roleId", "This role is too cool")
     */
    removeGuildRole(guildId: string, roleId: string, reason?: string): Promise<RESTDeleteAPIGuildRoleResult>;
    /**
     * Get the amount of members that would be pruned when a prune with the passed amount of days would be started
     * @param guildId Id of the guild
     * @param options Object with prune data
     * @returns Object with a "pruned" key indicating the amount of members that would be pruned
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | KICK_MEMBERS       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const data = await client.guild.getGuildPruneCount("guildId", { days: 7 })
     */
    getGuildPruneCount(guildId: string, options?: RESTGetAPIGuildPruneCountQuery): Promise<RESTGetAPIGuildPruneCountResult>;
    /**
     * Start a prune
     * @param guildId Id of the guild
     * @param data Object with prune data
     * @returns Object with a "pruned" key indicating the amount of members that were pruned
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | KICK_MEMBERS       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const data = await client.guild.startGuildPrune("guildId", { days: 7 })
     */
    startGuildPrune(guildId: string, data: RESTPostAPIGuildPruneJSONBody & {
        computer_prune_count: true;
        reason?: string;
    }): Promise<RESTPostAPIGuildPruneResult & {
        pruned: number;
    }>;
    startGuildPrune(guildId: string, data: RESTPostAPIGuildPruneJSONBody & {
        computer_prune_count: false;
        reason?: string;
    }): Promise<RESTPostAPIGuildPruneResult & {
        pruned: null;
    }>;
    /**
     * Get a list of voice regions for the guild, includes vip-regions unlike voice.getVoiceRegions
     * @param guildId Id of the guild
     * @returns List of [voice regions](https://discord.com/developers/docs/resources/voice#voice-region-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const regions = await client.guild.getGuildVoiceRegions("guildId")
     */
    getGuildVoiceRegions(guildId: string): Promise<RESTGetAPIGuildVoiceRegionsResult>;
    /**
     * Get invites for a guild
     * @param guildId Id of the guild
     * @returns List of [invites](https://discord.com/developers/docs/resources/invite#invite-object) (with metadata)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const invites = await client.guild.getGuildInvites("guildId")
     */
    getGuildInvites(guildId: string): Promise<RESTGetAPIGuildInvitesResult>;
    /**
     * Get integrations for a guild
     * @param guildId Id of the guild
     * @returns List of [integration objects](https://discord.com/developers/docs/resources/guild#integration-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const integrations = await client.guild.getGuildIntegrations("guildId")
     */
    getGuildIntegrations(guildId: string): Promise<RESTGetAPIGuildIntegrationsResult>;
    /**
     * Delete a guild integration
     * @param guildId Id of the guild
     * @param integrationId Id of the integration
     * @param reason Reason for removing the integration
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * await client.guild.deleteGuildIntegration("guildId", "integrationId", "Didn't need anymore")
     */
    removeGuildIntegration(guildId: string, integrationId: string, reason?: string): Promise<RESTDeleteAPIGuildIntegrationResult>;
    /**
     * Get a guild widget settings object
     * @param guildId Id of the guild
     * @returns [Guild Widget settings](https://discord.com/developers/docs/resources/guild#guild-widget-settings-object-guild-widget-settings-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const widgetSettings = await client.guild.getGuildWidgetSettings("guildId")
     */
    getGuildWidgetSettings(guildId: string): Promise<RESTGetAPIGuildWidgetSettingsResult>;
    /**
     * Update a guild widget settings object
     * @param guildId Id of the guild
     * @param data widget settings
     * @returns Updated [Guild Widget settings](https://discord.com/developers/docs/resources/guild#guild-widget-settings-object-guild-widget-settings-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * // Sets a widget as disabled
     * const client = new SnowTransfer("TOKEN")
     * const widgetSettings = await client.guild.updateGuildWidgetSettings("guildId", { enabled: false })
     */
    updateGuildWidgetSettings(guildId: string, data: Partial<RESTPatchAPIGuildWidgetSettingsJSONBody & {
        reason?: string;
    }>): Promise<RESTPatchAPIGuildWidgetSettingsResult>;
    /**
     * Gets a guild widget object
     * @param guildId Id of the guild
     * @returns [Guild Widget](https://discord.com/developers/docs/resources/guild#guild-widget-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const widget = await client.guild.getGuildWidget("guildId")
     */
    getGuildWidget(guildId: string): Promise<APIGuildWidget>;
    /**
     * Get a guild's vanity URL code
     * @param guildId Id of the guild
     * @returns partial [invite object](https://discord.com/developers/docs/resources/guild#get-guild-vanity-url-example-partial-invite-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const vanityUrl = await client.guild.getGuildVanityUrl("guildId")
     */
    getGuildVanityURL(guildId: string): Promise<RESTGetAPIGuildVanityUrlResult>;
    /**
     * Get a guild's welcome screen object
     * @param guildId Id of the guild
     * @returns [Guild Welcome Screen](https://discord.com/developers/docs/resources/guild#welcome-screen-object)
     *
     * | Permissions needed | Condition                            |
     * |--------------------|--------------------------------------|
     * | MANAGE_GUILD       | if the welcome screen is not enabled |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const welcomeScreen = await client.guild.getGuildWelcomeScreen("guildId")
     */
    getGuildWelcomeScreen(guildId: string): Promise<RESTGetAPIGuildWelcomeScreenResult>;
    /**
     * Update a guild welcome screen object
     * @param guildId Id of guild
     * @param data Welcome screen data
     * @returns [Guild Welcome Screen](https://discord.com/developers/docs/resources/guild#welcome-screen-object)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * // Disabled the welcome screen
     * const client = new SnowTransfer("TOKEN")
     * const welcomeScreen = await client.guild.updateGuildWelcomeScreen("guildId", { enabled: false })
     */
    editGuildWelcomeScreen(guildId: string, data: RESTPatchAPIGuildWelcomeScreenJSONBody & {
        reason?: string;
    }): Promise<RESTPatchAPIGuildWelcomeScreenResult>;
    /**
     * Updates the current user's voice state in a stage channel
     * @param guildId Id of the guild
     * @param data Data of the voice state
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition                           |
     * |--------------------|-------------------------------------|
     * | MUTE_MEMBERS       | when trying to un-suppress yourself |
     * | REQUEST_TO_SPEAK   | when trying to request to speak     |
     *
     * @example
     * // Unsuppresses the CurrentUser in the stage channel they're in
     * const client = new SnowTransfer("TOKEN")
     * client.guild.updateGuildVoiceState("guildId", { channel_id: "channel id", suppress: false })
     */
    updateCurrentUserVoiceState(guildId: string, data: RESTPatchAPIGuildVoiceStateCurrentMemberJSONBody): Promise<RESTPatchAPIGuildVoiceStateCurrentMemberResult>;
    /**
     * Updates a user's voice state in a stage channel
     * @param guildId Id of the guild
     * @param userId Id of the user
     * @param data Data of the voice state
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition                           |
     * |--------------------|-------------------------------------|
     * | MUTE_MEMBERS       | when trying to suppress/un-suppress |
     *
     * @example
     * // Suppresses the user in the stage channel they're in
     * const client = new SnowTransfer("TOKEN")
     * client.guild.updateGuildVoiceState("guildId", "userId", { channel_id: "channel id", suppress: true })
     */
    updateUserVoiceState(guildId: string, userId: string, data: RESTPatchAPIGuildVoiceStateUserJSONBody): Promise<RESTPatchAPIGuildVoiceStateUserResult>;
}

/**
 * Methods for interacting with Guild Scheduled Events
 */
declare class GuildScheduledEventMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Guild Scheduled Event Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.guildScheduledEvent.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get all scheduled events for a guild
     * @param guildId The Id of the guild
     * @param withCounts Include number of users subscribed to each event
     * @returns An array of [guild scheduled events](https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-structure)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const events = await client.guildScheduledEvent.listGuildScheduledEvents(guildId)
     */
    listGuildScheduledEvents(guildId: string, withCounts?: boolean): Promise<RESTGetAPIGuildScheduledEventsResult>;
    /**
     * Create a scheduled event for a guild
     * @param guildId The Id of the guild
     * @param data Data for the new scheduled event
     * @returns A [scheduled event](https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-structure)
     *
     * | Permissions needed | Condition                        |
     * |--------------------|----------------------------------|
     * | MANAGE_EVENTS      | always                           |
     * | MANAGE_CHANNELS    | If entity_type is STAGE_INSTANCE |
     * | MUTE_MEMBERS       | If entity_type is STAGE_INSTANCE |
     * | MOVE_MEMBERS       | If entity_type is STAGE_INSTANCE |
     * | VIEW_CHANNEL       | If entity_type is VOICE          |
     * | CONNECT            | If entity_type is VOICE          |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const eventData = {
     * 	name: "My event!",
     * 	entity_type: 1,
     * 	start_time: "2020-01-01T00:00:00Z",
     * 	privacy_level: 1
     * }
     * const event = await client.guildScheduledEvent.createGuildScheduledEvent(guildId, eventData)
     */
    createGuildScheduledEvent(guildId: string, data: RESTPostAPIGuildScheduledEventJSONBody): Promise<RESTPostAPIGuildScheduledEventResult>;
    /**
     * Get a specific scheduled event for a guild
     * @param guildId The Id of the guild
     * @param eventId The Id of the event
     * @param withCounts Include number of users subscribed to this event
     * @returns A [scheduled event](https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-structure)
     *
     * | Permissions needed | Condition                                 |
     * |--------------------|-------------------------------------------|
     * | VIEW_CHANNEL       | if entity_type is STAGE_INSTANCE or VOICE |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const event = await client.guildScheduledEvent.getGuildScheduledEvent(guildId, eventId)
     */
    getGuildScheduledEvent(guildId: string, eventId: string, withCounts?: boolean): Promise<RESTGetAPIGuildScheduledEventResult>;
    /**
     * Edit the details of a scheduled event for a guild
     * @param guildId The Id of the guild
     * @param eventId The Id of the event
     * @param data Edited scheduled event data
     * @returns A [scheduled event](https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-object-guild-scheduled-event-structure)
     *
     * | Permissions needed | Condition                        |
     * |--------------------|----------------------------------|
     * | MANAGE_EVENTS      | always                           |
     * | MANAGE_CHANNELS    | If entity_type is STAGE_INSTANCE |
     * | MUTE_MEMBERS       | If entity_type is STAGE_INSTANCE |
     * | MOVE_MEMBERS       | If entity_type is STAGE_INSTANCE |
     * | VIEW_CHANNEL       | If entity_type is VOICE          |
     * | CONNECT            | If entity_type is VOICE          |
     *
     * @example
     * // Updates a scheduled event to be an external event that will take place in Brazil and end in 2025
     * const client = new SnowTransfer("TOKEN")
     * const event = await client.guildScheduledEvent.editGuildScheduledEvent(guildId, eventId, { entity_type: 3, channel_id: null, entity_metadata: { location: "Brazil" }, scheduled_end_time: "2025-01-01T00:00:00.000Z" })
     */
    editGuildScheduledEvent(guildId: string, eventId: string, data: RESTPatchAPIGuildScheduledEventJSONBody): Promise<RESTPatchAPIGuildScheduledEventResult>;
    /**
     * Delete a specific scheduled event for a guild
     * @param guildId The Id of the guild
     * @param eventId The Id of the event
     * @returns Resolves the promise on successful execution
     *
     * | Permissions needed | Condition                        |
     * |--------------------|----------------------------------|
     * | MANAGE_EVENTS      | always                           |
     * | MANAGE_CHANNELS    | If entity_type is STAGE_INSTANCE |
     * | MUTE_MEMBERS       | If entity_type is STAGE_INSTANCE |
     * | MOVE_MEMBERS       | If entity_type is STAGE_INSTANCE |
     * | VIEW_CHANNEL       | If entity_type is VOICE          |
     * | CONNECT            | If entity_type is VOICE          |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.guildScheduledEvent.deleteGuildScheduledEvent(guildId, eventId)
     */
    deleteGuildScheduledEvent(guildId: string, eventId: string): Promise<RESTDeleteAPIGuildScheduledEventResult>;
    /**
     * Get a list of users attending a specific event
     * @param guildId The Id of the guild
     * @param eventId The Id of the event
     * @param options Options for how to get users
     * @returns An array of [event users](https://discord.com/developers/docs/resources/guild-scheduled-event#guild-scheduled-event-user-object-guild-scheduled-event-user-structure)
     *
     * | Permissions needed | Condition                                 |
     * |--------------------|-------------------------------------------|
     * | VIEW_CHANNEL       | if entity_type is STAGE_INSTANCE or VOICE |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const users = await client.guildScheduledEvent.getGuildScheduledEventUsers(guildId, eventId)
     */
    getGuildScheduledEventUsers(guildId: string, eventId: string, options?: RESTGetAPIGuildScheduledEventUsersQuery): Promise<RESTGetAPIGuildScheduledEventUsersResult>;
}

/**
 * Methods for interacting with Guild Templates
 */
declare class GuildTemplateMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Guild Template Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.guildTemplate.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get a guild template by code
     * @param code The code for the template
     * @returns A [guild template](https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const template = await client.guildTemplate.getGuildTemplate("code")
     */
    getGuildTemplate(code: string): Promise<RESTGetAPITemplateResult>;
    /**
     * Creates a guild from a template. If using a bot account, the bot can only be in < 10 guilds (guild create limitation)
     * @param code The code of the template
     * @param options Specific options for the new guild
     * @returns A [guild](https://discord.com/developers/docs/resources/guild#guild-object-guild-structure)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const guild = await client.guildTemplate.createGuildFromGuildTemplate("code", { name: "Cool guild" })
     */
    createGuildFromGuildTemplate(code: string, options: RESTPostAPITemplateCreateGuildJSONBody): Promise<RESTPostAPITemplateCreateGuildResult>;
    /**
     * Gets all templates from a guild
     * @param guildId The Id of the guild
     * @returns An array of [guild templates](https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const templates = await client.guildTemplate.getGuildTemplates("guildId")
     */
    getGuildTemplates(guildId: string): Promise<RESTGetAPIGuildTemplatesResult>;
    /**
     * Creates a template from the current state of the guild
     * @param guildId The Id of the guild
     * @param data Metadata for the template
     * @returns A [guild tempalte](https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const template = await client.guildTemplate.createGuildTemplate("guildId", { name: "Cool guild template", description: "This is a cool guild template" })
     */
    createGuildTemplate(guildId: string, data: RESTPostAPIGuildTemplatesJSONBody): Promise<RESTPostAPIGuildTemplatesResult>;
    /**
     * Updates a guild template to match the current state of the guild
     * @param guildId The Id of the guild
     * @param code The code of the template
     * @returns A [guild template](https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const template = await client.guildTemplate.syncGuildTemplate("guildId", "code")
     */
    syncGuildTemplate(guildId: string, code: string): Promise<RESTPutAPIGuildTemplateSyncResult>;
    /**
     * Updates a guild template's metadata
     * @param guildId The Id of the guild
     * @param code The code of the template
     * @param data Metadata for the template
     * @returns A [guild template](https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const template = await client.guildTemplate.modifyGuildTemplate("guildId", "code", { name: "Coolest guild template", description: "This is the coolest guild template hands down" })
     */
    modifyGuildTemplate(guildId: string, code: string, data: RESTPatchAPIGuildTemplateJSONBody): Promise<RESTPatchAPIGuildTemplateResult>;
    /**
     * Deletes a template from a guild
     * @param guildId The Id of the guild
     * @param code The code of the template
     * @returns A [guild template](https://discord.com/developers/docs/resources/guild-template#guild-template-object-guild-template-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_GUILD       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const template = await client.guildTemplate.deleteGuildTemplate("guildId", "code")
     */
    deleteGuildTemplate(guildId: string, code: string): Promise<RESTDeleteAPIGuildTemplateResult>;
}

/**
 * Methods for handling webhook interactions
 */
declare class WebhookMethods {
    requestHandler: RequestHandler;
    disableEveryone: boolean;
    /**
     * Create a new Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.webhook.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     * @param disableEveryone Disable [at]everyone/[at]here on outgoing messages
     */
    constructor(requestHandler: RequestHandler, disableEveryone: boolean);
    /**
     * Create a new Webhook
     * @param channelId Id of the channel
     * @param data Object with webhook properties
     * @returns [Webhook Object](https://discord.com/developers/docs/resources/webhook#webhook-object-webhook-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_WEBHOOKS    | always    |
     *
     * @example
     * // Create a new Webhook with the name "Webby Webhook"
     * const client = new SnowTransfer("TOKEN")
     * const webhookData = {
     * 	name: "Webby Webhook"
     * }
     * const webhook = await client.webhook.createWebhook("channel Id", webhookData)
     */
    createWebhook(channelId: string, data: RESTPostAPIChannelWebhookJSONBody): Promise<RESTPostAPIChannelWebhookResult>;
    /**
     * Get all webhooks within a channel
     * @param channelId Id of the channel
     * @returns Array of [Webhook Objects](https://discord.com/developers/docs/resources/webhook#webhook-object-webhook-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_WEBHOOKS    | always    |
     *
     * @example
     * // Get all webhooks within a channel
     * const client = new SnowTransfer("TOKEN")
     * const webhooks = await client.webhook.getChannelWebhooks("channel Id")
     */
    getChannelWebhooks(channelId: string): Promise<RESTGetAPIChannelWebhooksResult>;
    /**
     * Get all webhooks within a guild
     * @param guildId Id of the guild
     * @returns Array of [Webhook Objects](https://discord.com/developers/docs/resources/webhook#webhook-object-webhook-structure)
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_WEBHOOKS    | always    |
     *
     * @example
     * // Get all webhooks within a guild
     * const client = new SnowTransfer("TOKEN")
     * const webhooks = await client.webhook.getGuildWebhooks("guild Id")
     */
    getGuildWebhooks(guildId: string): Promise<RESTGetAPIGuildWebhooksResult>;
    /**
     * Get a single Webhook via Id
     * @param webhookId Id of the webhook
     * @param token Webhook token
     * @returns [Webhook Object](https://discord.com/developers/docs/resources/webhook#webhook-object-webhook-structure)
     *
     * | Permissions needed | Condition     |
     * |--------------------|---------------|
     * | MANAGE_WEBHOOKS    | without token |
     *
     * @example
     * // Get a webhook via Id providing a webhook token
     * const client = new SnowTransfer() // No token needed if webhook token is provided
     * const webhook = await client.webhook.getWebhook("webhook Id", "webhook token")
     */
    getWebhook(webhookId: string, token?: string): Promise<RESTGetAPIWebhookResult>;
    /**
     * Update a webhook
     * @param webhookId Id of the webhook
     * @param data Updated Webhook properties
     * @param token Webhook token
     * @returns Updated [Webhook Object](https://discord.com/developers/docs/resources/webhook#webhook-object-webhook-structure)
     *
     * | Permissions needed | Condition     |
     * |--------------------|---------------|
     * | MANAGE_WEBHOOKS    | without token |
     *
     * @example
     * // Rename a webhook to "Captain Hook" with a webhook token
     * const client = new SnowTransfer(); // No token needed if webhook token is provided
     * const webhookData = {
     * 	name: "Captain Hook"
     * }
     * const webhook = await client.webhook.updateWebhook("webhook Id", webhookData, "webhook token")
     */
    updateWebhook(webhookId: string, data: RESTPatchAPIWebhookWithTokenJSONBody & {
        reason?: string;
    }, token: string): Promise<RESTPatchAPIWebhookWithTokenResult>;
    updateWebhook(webhookId: string, data: RESTPatchAPIWebhookJSONBody & {
        reason?: string;
    }): Promise<RESTPatchAPIWebhookResult>;
    /**
     * Delete a Webhook
     * @param webhookId Id of the webhook
     * @param token Webhook token
     * @returns Resolves the Promise on successful execution
     *
     * | Permissions needed | Condition     |
     * |--------------------|---------------|
     * | MANAGE_WEBHOOKS    | without token |
     *
     * @example
     * // Delete a webhook via Id providing a webhook token
     * const client = new SnowTransfer(); // No token needed if webhook token is provided
     * client.webhook.deleteWebhook("webhook Id", "webhook token")
     */
    deleteWebhook(webhookId: string, token?: string): Promise<RESTDeleteAPIWebhookResult>;
    /**
     * Send a message via Webhook
     * @param webhookId Id of the webhook
     * @param token webhook token
     * @param data Webhook data to send
     * @param options Options for executing the webhook
     * @returns Resolves the Promise on successful execution unless wait is set to true, which returns a [message]() object
     *
     * @example
     * // Send a message saying "Hi from my webhook" with a previously created webhook
     * const client = new SnowTransfer()
     * client.webhook.executeWebhook("webhook Id", "webhook token", { content: "Hi from my webhook" })
     */
    executeWebhook(webhookId: string, token: string, data: RESTPostAPIWebhookWithTokenJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }, options?: RESTPostAPIWebhookWithTokenQuery & {
        wait?: false;
        disableEveryone?: boolean;
    }): Promise<RESTPostAPIWebhookWithTokenResult>;
    executeWebhook(webhookId: string, token: string, data: RESTPostAPIWebhookWithTokenJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }, options: RESTPostAPIWebhookWithTokenQuery & {
        wait: true;
        disableEveryone?: boolean;
    }): Promise<RESTPostAPIWebhookWithTokenWaitResult>;
    /**
     * Execute a slack style Webhook
     * @param webhookId Id of the Webhook
     * @param token Webhook token
     * @param data Check [Slack's documentation](https://api.slack.com/incoming-webhooks)
     * @param options Options for executing the webhook
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer() // No token needed
     * client.webhook.executeSlackWebhook("webhook Id", "webhook token", slackdata)
     */
    executeWebhookSlack(webhookId: string, token: string, data: any, options?: RESTPostAPIWebhookWithTokenSlackQuery & {
        wait?: false;
    }): Promise<RESTPostAPIWebhookWithTokenSlackResult>;
    executeWebhookSlack(webhookId: string, token: string, data: any, options?: RESTPostAPIWebhookWithTokenSlackQuery & {
        wait: true;
    }): Promise<RESTPostAPIWebhookWithTokenSlackWaitResult>;
    /**
     * Executes a github style Webhook
     * @param webhookId Id of the Webhook
     * @param token Webhook token
     * @param data Check [GitHub's documentation](https://docs.github.com/en/developers/webhooks-and-events/webhook-events-and-payloads#webhook-payload-object)
     * @param options Options for executing the webhook
     * @returns Resolves the Promise on successful execution
     */
    executeWebhookGitHub(webhookId: string, token: string, data: any, options?: RESTPostAPIWebhookWithTokenGitHubQuery & {
        wait?: false;
    }): Promise<RESTPostAPIWebhookWithTokenGitHubResult>;
    executeWebhookGitHub(webhookId: string, token: string, data: any, options?: RESTPostAPIWebhookWithTokenGitHubQuery & {
        wait: true;
    }): Promise<RESTPostAPIWebhookWithTokenGitHubWaitResult>;
    /**
     * Get a single message from a specific Webhook via Id
     * @param webhookId Id of the Webhook
     * @param token Webhook token
     * @param messageId Id of the message
     * @param threadId Id of the thread the message was sent in
     * @returns [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     */
    getWebhookMessage(webhookId: string, token: string, messageId: string, threadId?: string): Promise<RESTGetAPIWebhookWithTokenMessageResult>;
    /**
     * Edit a message sent by a Webhook
     * @param webhookId Id of the Webhook
     * @param token Webhook token
     * @param messageId Id of the message
     * @param data Data to send
     * @returns [discord message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * @example
     * const client = new SnowTransfer()
     * const message = await client.webhook.editWebhookMessage("webhook Id", "webhook token", "message Id", { content: "New content" })
     */
    editWebhookMessage(webhookId: string, token: string, messageId: string, data: RESTPatchAPIWebhookWithTokenMessageJSONBody & {
        thread_id?: string;
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }): Promise<RESTPatchAPIWebhookWithTokenMessageResult>;
    /**
     * Delete a message sent by a Webhook
     * @param webhookId Id of the Webhook
     * @param token Webhook token
     * @param messageId Id of the message
     * @param threadId Id of the thread the message was sent in
     * @returns Resolves the Promise on successful execution
     */
    deleteWebhookMessage(webhookId: string, token: string, messageId: string, threadId?: string): Promise<RESTDeleteAPIWebhookWithTokenMessageResult>;
}

/**
 * Methods for interacting with slash command specific endpoints
 */
declare class InteractionMethods {
    requestHandler: RequestHandler;
    webhooks: WebhookMethods;
    /**
     * Create a new Interaction Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.interaction.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     * @param webhooks WebhookMethods class that handles webhook related stuff
     */
    constructor(requestHandler: RequestHandler, webhooks: WebhookMethods);
    /**
     * Fetch all global commands for your application
     * @param appId The Id of the application
     * @param withLocalizations Whether or not to include localizations
     * @returns An Array of [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) objects
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const commands = await client.interaction.getApplicationCommands("appId")
     */
    getApplicationCommands(appId: string, withLocalizations?: boolean): Promise<RESTGetAPIApplicationCommandsResult>;
    /**
     * Create a new global command. New global commands will be available in all guilds after 1 hour
     * @param appId The Id of the application
     * @param data The command data
     * @returns An [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const command = await client.interaction.createApplicationCommand("appId", { name: "test", description: "testing 1, 2, 3" })
     */
    createApplicationCommand(appId: string, data: RESTPostAPIApplicationCommandsJSONBody): Promise<RESTPostAPIApplicationCommandsResult>;
    /**
     * Fetch a global command for your application
     * @param appId The Id of the application
     * @param cmdId The Id of the command
     * @returns An [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const command = await client.interaction.getApplicationCommand("appId", "cmdId")
     */
    getApplicationCommand(appId: string, cmdId: string): Promise<RESTGetAPIApplicationCommandResult>;
    /**
     * Edit a global command. Updates will be available in all guilds after 1 hour
     * @param appId The Id of the application
     * @param cmdId The Id of the command
     * @param data The command data
     * @returns An [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const command = await client.interaction.editApplicationCommand("appId", "cmdId", { name: "cool", description: "tells you how cool you are" })
     */
    editApplicationCommand(appId: string, cmdId: string, data: RESTPatchAPIApplicationCommandJSONBody): Promise<RESTPatchAPIApplicationCommandResult>;
    /**
     * Deletes a global command
     * @param appId The Id of the application
     * @param cmdId The Id of the command
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.interaction.deleteApplicationCommand("appId", "cmdId")
     */
    deleteApplicationCommand(appId: string, cmdId: string): Promise<never>;
    /**
     * Takes a list of application commands, overwriting existing commands that are registered globally for this application.
     * Updates will be available in all guilds after 1 hour
     * @param appId The Id of the application
     * @param data Array of commands
     * @returns An Array of [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) objects
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const commands = await client.interaction.bulkOverwriteApplicationCommands("appId", [{ name: "test", description: "testing 1, 2, 3" }])
     */
    bulkOverwriteApplicationCommands(appId: string, data: RESTPutAPIApplicationCommandsJSONBody): Promise<RESTPutAPIApplicationCommandsResult>;
    /**
     * Fetch all of the guild commands for your application for a specific guild.
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param withLocalizations Whether or not to include localizations
     * @returns An Array of [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) objects
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const commands = await client.interaction.getGuildCommands("appId", "guildId", true)
     */
    getGuildApplicationCommands(appId: string, guildId: string, withLocalizations?: boolean): Promise<RESTGetAPIApplicationGuildCommandsResult>;
    /**
     * Create a new guild command. New guild commands will be available in the guild immediately.
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param data Command data
     * @returns An [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const command = await client.interaction.createGuildApplicationCommand("appId", "guildId", { name: "test", description: "testing 1, 2, 3" })
     */
    createGuildApplicationCommand(appId: string, guildId: string, data: RESTPostAPIApplicationGuildCommandsJSONBody): Promise<RESTPostAPIApplicationGuildCommandsResult>;
    /**
     * Fetch a guild command for your application
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param cmdId The Id of the command
     * @returns An [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const command = await client.interaction.getGuildApplicationCommand("appId", "guildId", "cmdId")
     */
    getGuildApplicationCommand(appId: string, guildId: string, cmdId: string): Promise<RESTGetAPIApplicationGuildCommandResult>;
    /**
     * Edit a guild command. Updates for guild commands will be available immediately.
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param cmdId The Id of the command
     * @param data New command data
     * @returns An [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const command = await client.interaction.editGuildApplicationCommand("appId", "guildId", "cmdId", { name: "coolest", description: "tells you that you are the coolest" })
     */
    editGuildApplicationCommand(appId: string, guildId: string, cmdId: string, data: RESTPatchAPIApplicationGuildCommandJSONBody): Promise<RESTPatchAPIApplicationGuildCommandResult>;
    /**
     * Delete a guild command
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param cmdId The Id of the command
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.interaction.deleteGuildApplicationCommand("appId", "guildId", "cmdId")
     */
    deleteGuildApplicationCommand(appId: string, guildId: string, cmdId: string): Promise<never>;
    /**
     * Takes a list of application commands, overwriting existing commands for the guild
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param data Array of commands
     * @returns An Array of [application command](https://discord.com/developers/docs/interactions/application-commands#application-command-object-application-command-structure) objects
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const commands = await client.interaction.bulkOverwriteGuildApplicationCommands("appId", "guildId", [{ name: "test", description: "testing 1, 2, 3" }])
     */
    bulkOverwriteGuildApplicationCommands(appId: string, guildId: string, data: RESTPutAPIApplicationGuildCommandsJSONBody): Promise<RESTPutAPIApplicationGuildCommandsResult>;
    /**
     * Fetches command permissions for all or a specific command for your application in a guild
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param cmdId The Id of the command
     * @returns An Array or single [guild application command permission](https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-guild-application-command-permissions-structure) objects
     *
     * @example
     * // Gets all commands' permissions
     * const client = new SnowTransfer("TOKEN")
     * const permissions = await client.interaction.getGuildApplicationCommandPermissions("appId", "guildId")
     *
     * @example
     * // Gets a specific command's permissions
     * const client = new SnowTransfer("TOKEN")
     * const permissions = await client.interaction.getGuildApplicationCommandPermissions("appId", "guildId", "cmdId")
     */
    getGuildApplicationCommandPermissions(appId: string, guildId: string): Promise<Array<RESTGetAPIApplicationCommandPermissionsResult>>;
    getGuildApplicationCommandPermissions(appId: string, guildId: string, cmdId: string): Promise<RESTGetAPIApplicationCommandPermissionsResult>;
    /**
     * Edits command permissions for a specific command for your application in a guild. You can only add up to 10 permission overwrites for a command.
     * @param appId The Id of the application
     * @param guildId The Id of the guild
     * @param cmdId The Id of the command
     * @param permissions New application command permissions data
     * @returns A [guild application command permission](https://discord.com/developers/docs/interactions/application-commands#application-command-permissions-object-guild-application-command-permissions-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const permissions = await client.interaction.editGuildApplicationCommandPermissions("appId", "guildId", "cmdId", [{ type: 2, id: "userId", permission: true }])
     */
    editGuildApplicationCommandPermissions(appId: string, guildId: string, cmdId: string, permissions: RESTPutAPIApplicationCommandPermissionsJSONBody["permissions"]): Promise<RESTPutAPIApplicationCommandPermissionsResult>;
    /**
     * Create a response to an Interaction
     *
     * When uploading attachments to respond to message interactions, you must provide the top level files property
     * which needs to match attachments array length and each element needs to match the same indexes as where their filename is defined (the top level files property gets deleted before it's appended to payload_json).
     * Should you have a more elegant solution, possibly rewriting the interface with the request handler, please submit a PR/issue.
     * @param interactionId The Id of the interaction
     * @param token The token of the interaction
     * @param data Response data
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * // Respond to a message interaction
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * client.interaction.createInteractionResponse("interactionId", "token", { type: 4, data: { content: "Hello World" } })
     */
    createInteractionResponse(interactionId: string, token: string, data: RESTPostAPIInteractionCallbackJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }): Promise<void>;
    /**
     * Returns the initial Interaction response
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @returns A [message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * const message = await client.interaction.getOriginalInteractionResponse("appId", "token")
     */
    getOriginalInteractionResponse(appId: string, token: string): Promise<RESTGetAPIInteractionOriginalResponseResult>;
    /**
     * Edits the initial Interaction response
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @param data New response data
     * @returns A [message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * const message = await client.interaction.editOriginalInteractionResponse("appId", "token", { content: "The world said hello back" })
     */
    editOriginalInteractionResponse(appId: string, token: string, data: RESTPatchAPIInteractionOriginalResponseJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }): Promise<RESTPatchAPIInteractionOriginalResponseResult>;
    /**
     * Deletes the initial Interaction response
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * client.interaction.deleteOriginalInteractionResponse("appId", "token")
     */
    deleteOriginalInteractionResponse(appId: string, token: string): Promise<RESTDeleteAPIInteractionOriginalResponseResult>;
    /**
     * Create a followup message for an Interaction
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @param data Message data
     * @returns A [message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * const message = await client.interaction.createFollowupMessage("appId", "token", { content: "The pacer gram fitness test-" })
     */
    createFollowupMessage(appId: string, token: string, data: RESTPostAPIInteractionFollowupJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }): Promise<RESTPostAPIInteractionFollowupResult>;
    /**
     * Get a followup message for an Interaction
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @param messageId The Id of the message
     * @returns A [message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * const message = await client.interaction.getFollowupMessage("appId", "token", "messageId")
     */
    getFollowupMessage(appId: string, token: string, messageId: string): Promise<RESTGetAPIInteractionFollowupResult>;
    /**
     * Edits a followup message for an Interaction
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @param messageId The Id of the message
     * @param data The new message data
     * @returns A [message](https://discord.com/developers/docs/resources/channel#message-object) object
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * const message = await client.interaction.editFollowupMessage("appId", "token", "messageId", { content: "-is a multistage aerobic capacity test" })
     */
    editFollowupMessage(appId: string, token: string, messageId: string, data: RESTPatchAPIInteractionFollowupJSONBody & {
        files?: Array<{
            name: string;
            file: Buffer | Readable | ReadableStream;
        }>;
    }): Promise<RESTPatchAPIInteractionFollowupResult>;
    /**
     * Deletes a followup message for an Interaction
     * @param appId The Id of the application
     * @param token The token of the interaction
     * @param messageId The Id of the message
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer() // This endpoint does not require a Bot token. The interaction token alone will suffice
     * client.interaction.deleteFollowupMessage("appId", "token", "messageId")
     */
    deleteFollowupMessage(appId: string, token: string, messageId: string): Promise<RESTDeleteAPIInteractionFollowupResult>;
}

/**
 * Methods for interacting with invites
 */
declare class InviteMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Invite Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.invite.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get the invite data on an invite id
     * @param inviteId Id of the invite
     * @param options Query params for additional metadata fields
     * @returns [Invite Object](https://discord.com/developers/docs/resources/invite#invite-object)
     *
     * @example
     * // Gets an invite with approximate_member_count and approximate_presence_count
     * const client = new SnowTransfer("TOKEN")
     * const invite = await client.invite.getInvite("inviteId", { with_counts: true })
     */
    getInvite(inviteId: string, options?: RESTGetAPIInviteQuery): Promise<RESTGetAPIInviteResult>;
    /**
     * Delete an invite
     * @param inviteId
     * @returns [Invite Object](https://discord.com/developers/docs/resources/invite#invite-object)
     *
     * | Permissions needed | Condition                                     |
     * |--------------------|-----------------------------------------------|
     * | MANAGE_CHANNELS    | for invite that belongs to a specific channel |
     * | MANAGE_GUILD       | delete any invite guild wide                  |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const invite = await client.invite.deleteInvite("inviteId")
     */
    deleteInvite(inviteId: string): Promise<RESTDeleteAPIInviteResult>;
}

/**
 * Methods for interacting with Stage instances
 */
declare class StageInstanceMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Stage Instance Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.stageInstance.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Creates a new stage instance associated to a stage channel
     * @param data The options for creating a stage instance
     * @returns a [stage instance](https://discord.com/developers/docs/resources/stage-instance#auto-closing-stage-instance-structure) object
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_CHANNELS    | always    |
     * | MUTE_MEMBERS       | always    |
     * | MOVE_MEMBERS       | always    |
     *
     * @example
     * // Create a new stage instance for channel id and the topic "This My House"
     * const client = new SnowTransfer("TOKEN")
     * const instance = await client.stageInstance.createStageInstance({ channel_id: "channel id", topic: "This My House" })
     */
    createStageInstance(data: RESTPostAPIStageInstanceJSONBody & {
        reason?: string;
    }): Promise<RESTPostAPIStageInstanceResult>;
    /**
     * Gets the stage instance associated to a stage channel if it exists
     * @param channelId Id of the stage channel
     * @returns a [stage instance](https://discord.com/developers/docs/resources/stage-instance#auto-closing-stage-instance-structure) object
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const instance = await client.stageInstance.getStageInstance("channel id")
     */
    getStageInstance(channelId: string): Promise<RESTGetAPIStageInstanceResult>;
    /**
     * Updates an existing stage instance
     * @param channelId Id of the stage channel
     * @param data The new data to send
     * @returns a [stage instance](https://discord.com/developers/docs/resources/stage-instance#auto-closing-stage-instance-structure) object
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_CHANNELS    | always    |
     * | MUTE_MEMBERS       | always    |
     * | MOVE_MEMBERS       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const instance = await client.stageInstance.updateStageInstance("channel id", { topic: "This my city, this my town" })
     */
    editStageInstance(channelId: string, data: RESTPatchAPIStageInstanceJSONBody & {
        reason?: string;
    }): Promise<RESTPatchAPIStageInstanceResult>;
    /**
     * Delete an existing stage instance
     * @param channelId Id of the stage channel
     * @param reason Reason for deleting the stage instance
     * @returns a [stage instance](https://discord.com/developers/docs/resources/stage-instance#auto-closing-stage-instance-structure) object
     *
     * | Permissions needed | Condition |
     * |--------------------|-----------|
     * | MANAGE_CHANNELS    | always    |
     * | MUTE_MEMBERS       | always    |
     * | MOVE_MEMBERS       | always    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.stageInstance.deleteStageInstance("channel id", "They already know who's house this is")
     */
    deleteStageInstance(channelId: string, reason?: string): Promise<RESTDeleteAPIStageInstanceResult>;
}

/**
 * Methods for interacting with users
 */
declare class UserMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new User Method handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.user.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get information about the CurrentUser
     * @returns A [user object](https://discord.com/developers/docs/resources/user#user-object)
     *
     * | OAUTH2 Scopes | Condition     |
     * |---------------|---------------|
     * | identify      | Without email |
     * | email         | With email    |
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const self = await client.user.getSelf()
     */
    getSelf(): Promise<RESTGetAPICurrentUserResult>;
    /**
     * Get information about a user via Id
     * @param userId Id of the user
     * @returns [user object](https://discord.com/developers/docs/resources/user#user-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const user = await client.user.getUser("userId")
     */
    getUser(userId: string): Promise<RESTGetAPIUserResult>;
    /**
     * Update the current user
     * @param data The new data of the CurrentUser
     * @returns [user object](https://discord.com/developers/docs/resources/user#user-object)
     *
     * @example
     * // update the avatar of the user
     * const client = new SnowTransfer("TOKEN")
     * const fileData = fs.readFileSync("new_avatar.png") // You should probably use fs.promises.readFile, since it is asynchronous, synchronous methods may lag your bot.
     * const updateData = \{
     * 	avatar: `data:image/png;base64,${fileData.toString("base64")}` // base64 data url: data:mimetype;base64,base64String
     * \}
     * client.user.updateSelf(updateData)
     */
    updateSelf(data: RESTPatchAPICurrentUserJSONBody): Promise<RESTPatchAPICurrentUserResult>;
    /**
     * Get guilds of the current user
     * @param options Options for getting guilds
     * @returns Array of [partial guild objects](https://discord.com/developers/docs/resources/guild#guild-object)
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const guilds = await client.user.getGuilds()
     */
    getGuilds(options?: RESTGetAPICurrentUserGuildsQuery): Promise<RESTGetAPICurrentUserGuildsResult>;
    /**
     * Leaves a guild
     * @param guildId Id of the guild
     * @returns Resolves the Promise on successful execution
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * client.user.leaveGuild("guildId")
     */
    leaveGuild(guildId: string): Promise<RESTDeleteAPICurrentUserGuildResult>;
    /**
     * Create a direct message channel with another user
     *
     * **You can not create a dm with another bot**
     * @param userId Id of the user to create the direct message channel with
     * @returns A [DM channel](https://discord.com/developers/docs/resources/channel#channel-object)
     *
     * @example
     * // Create a dm channel and send "hi" to it
     * const client = new SnowTransfer("TOKEN")
     * const channel = await client.user.createDirectMessageChannel("other user id")
     * client.channel.createMessage(channel.id, "hi")
     */
    createDirectMessageChannel(userId: string): Promise<RESTPostAPICurrentUserCreateDMChannelResult>;
    /**
     * Create a group direct message channel with other users
     *
     * @param data An object containing a list of access tokens with gdm.join and optionally, a nickname dictionary keyed by user IDs with strings as values
     * @returns A [DM channel](https://discord.com/developers/docs/resources/channel#channel-object)
     *
     * | OAUTH2 Scopes | Condition            |
     * |---------------|----------------------|
     * | gdm.join      | always for each user |
     *
     * @example
     * // Create a group dm channel and send "hi" to it
     * const client = new SnowTransfer("TOKEN")
     * const channel = await client.user.createGroupDirectMessageChannel({ access_tokens: ["user 1 access token", "user 2 access token"], { "320067006521147393": "Brad", "128392910574977024": "Wolke" } })
     * client.channel.createMessage(channel.id, "hi")
     */
    createGroupDirectMessageChannel(data: {
        access_tokens: Array<string>;
        nicks?: {
            [userId: string]: string;
        };
    }): Promise<RESTPostAPICurrentUserCreateDMChannelResult>;
    /**
     * Returns a list of connections for the current user
     * @returns A list of [connections](https://discord.com/developers/docs/resources/user#connection-object)
     *
     * | OAUTH2 Scopes | Condition |
     * |---------------|-----------|
     * | connections   | always    |
     *
     * @example
     * // Get all user's connections
     * const client = new SnowTransfer("TOKEN")
     * const connections = await client.user.getConnections()
     */
    getConnections(): Promise<RESTGetAPICurrentUserConnectionsResult>;
    /**
     * Gets a role connection for the current user
     * @param appId Id of the application
     * @returns An [Application role connection](https://discord.com/developers/docs/resources/user#application-role-connection-object)
     *
     * | OAUTH2 Scopes          | Condition |
     * |------------------------|-----------|
     * | role_connections.write | always    |
     *
     * @example
     * // Get a role connection for an app
     * const client = new SnowTransfer("TOKEN")
     * const connection = await client.user.getApplicationRoleConnection("app id")
     */
    getApplicationRoleConnection(appId: string): Promise<RESTGetAPICurrentUserApplicationRoleConnectionResult>;
    /**
     * Updates a role connection for the current user
     * @param appId Id of the application
     * @returns An [Application role connection](https://discord.com/developers/docs/resources/user#application-role-connection-object)
     *
     * | OAUTH2 Scopes          | Condition |
     * |------------------------|-----------|
     * | role_connections.write | always    |
     *
     * @example
     * // Updates a role connection for an app
     * const client = new SnowTransfer("TOKEN")
     * const connection = await client.user.updateApplicationRoleConnection("app id", { platform_name: "some platform", platform_username: "Cool user 22" })
     */
    updateApplicationRoleConnection(appId: string, data: RESTPutAPICurrentUserApplicationRoleConnectionJSONBody): Promise<RESTPutAPICurrentUserApplicationRoleConnectionResult>;
}

/**
 * Methods for interacting with some voice
 */
declare class VoiceMethods {
    requestHandler: RequestHandler;
    /**
     * Create a new Voice Method Handler
     *
     * Usually SnowTransfer creates a method handler for you, this is here for completion
     *
     * You can access the methods listed via `client.voice.method`, where `client` is an initialized SnowTransfer instance
     * @param requestHandler request handler that calls the rest api
     */
    constructor(requestHandler: RequestHandler);
    /**
     * Get currently available voice regions that can be used when creating servers
     * @returns Array of [voice region](https://discord.com/developers/docs/resources/voice#voice-region-object) objects
     *
     * @example
     * const client = new SnowTransfer("TOKEN")
     * const regions = await client.voice.getVoiceRegions()
     */
    getVoiceRegions(): Promise<RESTGetAPIVoiceRegionsResult>;
}

declare const Constants: {
    REST_API_VERSION: 10;
    GET_CHANNEL_MESSAGES_MIN_RESULTS: 1;
    GET_CHANNEL_MESSAGES_MAX_RESULTS: 100;
    GET_GUILD_SCHEDULED_EVENT_USERS_MIN_RESULTS: 1;
    GET_GUILD_SCHEDULED_EVENT_USERS_MAX_RESULTS: 100;
    SEARCH_MEMBERS_MIN_RESULTS: 1;
    SEARCH_MEMBERS_MAX_RESULTS: 1000;
    BULK_DELETE_MESSAGES_MIN: 2;
    BULK_DELETE_MESSAGES_MAX: 100;
    OK_STATUS_CODES: Set<number>;
    DO_NOT_RETRY_STATUS_CODES: Set<number>;
    DEFAULT_RETRY_LIMIT: number;
    standardMultipartHandler(data: {
        files: Array<{
            name: string;
            file: Buffer | Blob | File | Readable | ReadableStream;
        }>;
        data?: any;
    }): FormData;
    standardAddToFormHandler(form: FormData, name: string, value: Buffer | Blob | File | Readable | ReadableStream, filename?: string): void;
};

/**
 * Mostly taken from https://github.com/abalabahaha/eris/blob/master/lib/rest/Endpoints.js
 *
 * Removed User-only endpoints
 */
declare const Endpoints: {
    BASE_URL: "/api/v10";
    BASE_HOST: "https://discord.com";
    CDN_URL: "https://cdn.discordapp.com";
    APPLICATION_COMMAND: (appID: string, cmdID: string) => "/applications/{app_id}/commands/{cmd_id}";
    APPLICATION_COMMANDS: (appID: string) => "/applications/{app_id}/commands";
    APPLICATION_GUILD_COMMANDS_PERMISSIONS: (appID: string, guildID: string) => "/applications/{app_id}/guilds/{guild_id}/commands/permissions";
    APPLICATION_GUILD_COMMAND_PERMISSIONS: (appID: string, guildID: string, cmdID: string) => "/applications/{app_id}/guilds/{guild_id}/commands/{cmd_id}/permissions";
    APPLICATION_GUILD_COMMAND: (appID: string, guildID: string, cmdID: string) => "/applications/{app_id}/guilds/{guild_id}/commands/{cmd_id}";
    APPLICATION_GUILD_COMMANDS: (appID: string, guildID: string) => "/applications/{app_id}/guilds/{guild_id}/commands";
    CHANNEL: (chanID: string) => "/channels/{channel_id}";
    CHANNEL_ATTACHMENTS: (chanID: string) => "/channels/{channel_id}/attachments";
    CHANNEL_BULK_DELETE: (chanID: string) => "/channels/{channel_id}/messages/bulk-delete";
    CHANNEL_FOLLOWERS: (chanID: string) => "/channels/{channel_id}/followers";
    CHANNEL_INVITES: (chanID: string) => "/channels/{channel_id}/invites";
    CHANNEL_MESSAGE: (chanID: string, msgID: string) => "/channels/{channel_id}/messages/{message_id}";
    CHANNEL_MESSAGE_CROSSPOST: (chanID: string, msgID: string) => "/channels/{channel_id}/messages/{message_id}/crosspost";
    CHANNEL_MESSAGE_REACTION: (chanID: string, msgID: string, reaction: string) => "/channels/{channel_id}/messages/{message_id}/reactions/{reaction}";
    CHANNEL_MESSAGE_REACTION_USER: (chanID: string, msgID: string, reaction: string, userID: string) => "/channels/{channel_id}/messages/{message_id}/reactions/{reaction}/{user_id}";
    CHANNEL_MESSAGE_REACTIONS: (chanID: string, msgID: string) => "/channels/{channel_id}/messages/{message_id}/reactions";
    CHANNEL_MESSAGE_THREADS: (chanID: string, msgID: string) => "/channels/{channel_id}/messages/{message_id}/threads";
    CHANNEL_MESSAGES: (chanID: string) => "/channels/{channel_id}/messages";
    CHANNEL_PERMISSION: (chanID: string, permID: string) => "/channels/{channel_id}/permissions/{perm_id}";
    CHANNEL_PERMISSIONS: (chanID: string) => "/channels/{channel_id}/permissions";
    CHANNEL_PIN: (chanID: string, msgID: string) => "/channels/{channel_id}/pins/{message_id}";
    CHANNEL_PINS: (chanID: string) => "/channels/{channel_id}/pins";
    CHANNEL_RECIPIENT: (chanID: string, userID: string) => "/channels/{channel_id}/recipients/{user_id}";
    CHANNEL_THREADS: (chanID: string) => "/channels/{channel_id}/threads";
    CHANNEL_THREAD_MEMBER: (chanID: string, memberID: string) => "/channels/{channel_id}/thread-members/{member_id}";
    CHANNEL_THREAD_MEMBERS: (chanID: string) => "/channels/{channel_id}/thread-members";
    CHANNEL_THREADS_ARCHIVED_PRIVATE: (chanID: string) => "/channels/{channel_id}/threads/archived/private";
    CHANNEL_THREADS_ARCHIVED_PRIVATE_USER: (chanID: string) => "/channels/{channel_id}/users/@me/threads/archived/private";
    CHANNEL_THREADS_ARCHIVED_PUBLIC: (chanID: string) => "/channels/{channel_id}/threads/archived/public";
    CHANNEL_TYPING: (chanID: string) => "/channels/{channel_id}/typing";
    CHANNEL_WEBHOOKS: (chanID: string) => "/channels/{channel_id}/webhooks";
    CHANNELS: "/channels";
    GATEWAY: "/gateway";
    GATEWAY_BOT: "/gateway/bot";
    GUILD: (guildID: string) => "/guilds/{guild_id}";
    GUILD_AUDIT_LOGS: (guildID: string) => "/guilds/{guild_id}/audit-logs";
    GUILD_AUTO_MOD_RULE: (guildID: string, ruleID: string) => "/guilds/{guild_id}/auto-moderation/rules/{rule_id}";
    GUILD_AUTO_MOD_RULES: (guildID: string) => "/guilds/{guild_id}/auto-moderation/rules";
    GUILD_BAN: (guildID: string, memberID: string) => "/guilds/{guild_id}/bans/{member_id}";
    GUILD_BANS: (guildID: string) => "/guilds/{guild_id}/bans";
    GUILD_CHANNELS: (guildID: string) => "/guilds/{guild_id}/channels";
    GUILD_EMOJI: (guildID: string, emojiID: string) => "/guilds/{guild_id}/emojis/{emoji_id}";
    GUILD_EMOJIS: (guildID: string) => "/guilds/{guild_id}/emojis";
    GUILD_INVITES: (guildID: string) => "/guilds/{guild_id}/invites";
    GUILD_INTEGRATION: (guildID: string, integrationID: string) => "/guilds/{guild_id}/integrations/{integration_id}";
    GUILD_INTEGRATIONS: (guildID: string) => "/guilds/{guild_id}/integrations";
    GUILD_MEMBER: (guildID: string, memberID: string) => "/guilds/{guild_id}/members/{member_id}";
    GUILD_MEMBER_ROLE: (guildID: string, memberID: string, roleID: string) => "/guilds/{guild_id}/members/{member_id}/roles/{role_id}";
    GUILD_MEMBERS: (guildID: string) => "/guilds/{guild_id}/members";
    GUILD_MEMBERS_SEARCH: (guildID: string) => "/guilds/{guild_id}/members/search";
    GUILD_PREVIEW: (guildID: string) => "/guilds/{guild_id}/preview";
    GUILD_PRUNE: (guildID: string) => "/guilds/{guild_id}/prune";
    GUILD_ROLE: (guildID: string, roleID: string) => "/guilds/{guild_id}/roles/{role_id}";
    GUILD_ROLES: (guildID: string) => "/guilds/{guild_id}/roles";
    GUILD_SCHEDULED_EVENTS: (guildID: string) => "/guilds/{guild_id}/scheduled-events";
    GUILD_SCHEDULED_EVENT: (guildID: string, eventId: string) => "/guilds/{guild_id}/scheduled-events/{event_id}";
    GUILD_SCHEDULED_EVENT_USERS: (guildID: string, eventId: string) => "/guilds/{guild_id}/scheduled-events/{event_id}/users";
    GUILD_STICKER: (guildID: string, stickerID: string) => "/guilds/{guild_id}/stickers/{sticker_id}";
    GUILD_STICKERS: (guildID: string) => "/guilds/{guild_id}/stickers";
    GUILD_TEMPLATE: (guildID: string, code: string) => "/guilds/{guild_id}/templates/{code}";
    GUILD_THREADS_ACTIVE: (guildID: string) => "/guilds/{guild_id}/threads/active";
    GUILD_TEMPLATES: (guildID: string) => "/guilds/{guild_id}/templates";
    GUILD_VANITY: (guildID: string) => "/guilds/{guild_id}/vanity-url";
    GUILD_VOICE_REGIONS: (guildID: string) => "/guilds/{guild_id}/regions";
    GUILD_VOICE_STATE_USER: (guildID: string, memberID: string) => "/guilds/{guild_id}/voice-states/{member_id}";
    GUILD_WEBHOOKS: (guildID: string) => "/guilds/{guild_id}/webhooks";
    GUILD_WELCOME_SCREEN: (guildID: string) => "/guilds/{guild_id}/welcome-screen";
    GUILD_WIDGET: (guildID: string) => "/guilds/{guild_id}/widget.json";
    GUILD_WIDGET_SETTINGS: (guildID: string) => "/guilds/{guild_id}/widget";
    GUILDS: "/guilds";
    INTERACTION_CALLBACK: (interactionID: string, token: string) => "/interactions/{interaction_id}/{token}/callback";
    INVITES: (inviteID: string) => "/invites/{invite_id}";
    OAUTH2_APPLICATION: (appID: string) => "/oauth2/applications/{app_id}";
    STAGE_INSTANCE_CHANNEL: (chanID: string) => "/stage-instances/{channel_id}";
    STAGE_INSTANCES: "/stage-instances";
    STICKER: (stickerID: string) => "/stickers/{sticker_id}";
    TEMPLATE: (code: string) => "/guilds/templates/{code}";
    USER: (userID: string) => "/users/{user_id}";
    USER_APPLICATION_ROLE_CONNECTION: (userID: string, appID: string) => "/users/{user_id}/applications/{app_id}/role-connection";
    USER_CHANNELS: (userID: string) => "/users/{user_id}/channels";
    USER_CONNECTIONS: (userID: string) => "/users/{user_id}/connections";
    USER_GUILD: (userID: string, guildID: string) => "/users/{user_id}/guilds/{guild_id}";
    USER_GUILDS: (userID: string) => "/users/{user_id}/guilds";
    USERS: "/users";
    VOICE_REGIONS: "/voice/regions";
    WEBHOOK: (hookID: string) => "/webhooks/{hook_id}";
    WEBHOOK_TOKEN: (hookID: string, token: string) => "/webhooks/{hook_id}/{token}";
    WEBHOOK_TOKEN_GITHUB: (hookID: string, token: string) => "/webhooks/{hook_id}/{token}/github";
    WEBHOOK_TOKEN_MESSAGE: (hookID: string, token: string, msgID: string) => "/webhooks/{hook_id}/{token}/messages/{message_id}";
    WEBHOOK_TOKEN_SLACK: (hookID: string, token: string) => "/webhooks/{hook_id}/{token}/slack";
};

declare class SnowTransfer {
    /** Options for this SnowTransfer instance */
    options: {
        /** The URL to start requests from. eg: https://discord.com */
        baseHost: string;
        /** If methods that send messages should have their content processed to remove [at]everyone and [at]here */
        disableEveryone: boolean;
        /** If rate limit buckets should be totally bypassed and functions are executed as fast as possible. Only use if you are 100% certain you wont run into issues or if you are proxying */
        bypassBuckets: boolean;
        /** If failed requests that can be retried should be retried, up to retryLimit times. */
        retryRequests: boolean;
        /** How many times requests should be retried if they fail and can be retried. */
        retryLimit: number;
    };
    /** The access token to use for requests. Can be a bot or bearer token */
    token: string | undefined;
    /** Methods related to channels */
    channel: ChannelMethods;
    /** Helper to execute REST calls */
    requestHandler: RequestHandler;
    /** Methods related to users */
    user: UserMethods;
    /** Methods related to stickers and emojis */
    guildAssets: GuildAssetsMethods;
    /** Methods related to webhooks */
    webhook: WebhookMethods;
    /** Methods related to guilds */
    guild: GuildMethods;
    /** Methods related to guild scheduled events */
    guildScheduledEvent: GuildScheduledEventMethods;
    /** Methods related to guild templates */
    guildTemplate: GuildTemplateMethods;
    /** Methods related to application commands/interactions */
    interaction: InteractionMethods;
    /** Methods related to invites */
    invite: InviteMethods;
    /** Methods related to voice regions */
    voice: VoiceMethods;
    /** Methods related to getting gateway connect info */
    bot: BotMethods;
    /** Methods related to guild audit logs */
    auditLog: AuditLogMethods;
    /** Methods related to guild stage instances */
    stageInstance: StageInstanceMethods;
    /** Methods related to guild auto mod */
    autoMod: AutoModerationMethods;
    /** Ratelimiter used for handling the ratelimits imposed by the rest api */
    ratelimiter: Ratelimiter;
    /**
     * Create a new Rest Client
     * @param token Discord Bot token to use
     * @param options options
     */
    constructor(token?: string, options?: Partial<SnowTransfer["options"]>);
}

export { AuditLogMethods, AutoModerationMethods, BotMethods, ChannelMethods, Constants, DiscordAPIError, Endpoints, GlobalBucket, GuildAssetsMethods, GuildMethods, GuildScheduledEventMethods, GuildTemplateMethods, type HTTPMethod, type HandlerEvents, InteractionMethods, InviteMethods, LocalBucket, Ratelimiter, RequestHandler, SnowTransfer, StageInstanceMethods, UserMethods, VoiceMethods, WebhookMethods };
